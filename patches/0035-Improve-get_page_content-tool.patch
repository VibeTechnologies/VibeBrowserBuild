From 3342d74345ad48ba7eacffb1da3b6d856239311e Mon Sep 17 00:00:00 2001
From: Den <2119348+dzianisv@users.noreply.github.com>
Date: Sat, 26 Jul 2025 11:27:24 +0300
Subject: [PATCH 035/107] Improve get_page_content tool

---
 chrome/browser/resources/vibe/ai_agent.js     |   2 +-
 .../resources/vibe/ai_tools.extension.js      | 195 ++----
 chrome/browser/resources/vibe/background.js   | 193 +++--
 .../vibe/combineMarkdownWithControls.test.js  | 663 ++++++++++++++++++
 chrome/browser/resources/vibe/content.js      | 250 ++++++-
 5 files changed, 1045 insertions(+), 258 deletions(-)
 create mode 100644 chrome/browser/resources/vibe/combineMarkdownWithControls.test.js

diff --git a/chrome/browser/resources/vibe/ai_agent.js b/chrome/browser/resources/vibe/ai_agent.js
index cb550679e4..d9a9f4560b 100644
--- a/chrome/browser/resources/vibe/ai_agent.js
+++ b/chrome/browser/resources/vibe/ai_agent.js
@@ -375,7 +375,7 @@ If asked to find a product, check amazon.com, walmart.com, aliexpress.com, temu.
         const navigateTool = tools.find(t => t.name === 'navigate_to_url');
         if (navigateTool) {
           try {
-            const navResult = await navigateTool.call({ url: 'https://flights.google.com' }, tabId);
+            const navResult = await navigateTool.call({ tabId: tabId, url: 'https://flights.google.com' });
             console.log('âœˆï¸ [AI_AGENT] Forced navigation executed:', navResult);
             
             toolResults.push({
diff --git a/chrome/browser/resources/vibe/ai_tools.extension.js b/chrome/browser/resources/vibe/ai_tools.extension.js
index 8edd3d3cac..a0dc72a057 100644
--- a/chrome/browser/resources/vibe/ai_tools.extension.js
+++ b/chrome/browser/resources/vibe/ai_tools.extension.js
@@ -18,21 +18,6 @@ const ALLOWED_HOSTNAMES = [
   'youtube.com', 'linkedin.com', 'twitter.com', 'facebook.com'
 ];
 
-// Utility function to check if an error is recoverable
-function isRecoverableError(errorMessage) {
-  const recoverableErrors = [
-    'comboboxSelectors is not defined',
-    'Element not found',
-    'Could not find element',
-    'No input appeared',
-    'ReferenceError',
-    'TypeError: Cannot read'
-  ];
-  
-  return recoverableErrors.some(error => 
-    errorMessage.toLowerCase().includes(error.toLowerCase())
-  );
-}
 
 // Utility function to validate URL security
 function validateUrlSecurity(url) {
@@ -393,80 +378,22 @@ class GetPageContentTool extends BrowserTool {
     try {
       const targetTab = tabId ? { id: tabId } : await getCurrentActiveTab();
       
-      // Execute script to extract page content
-      const [{ result, error }] = await chrome.scripting.executeScript({
-        target: { tabId: targetTab.id },
-        func: () => {
-          try {
-            // Extract all visible text content from the page
-            const walker = document.createTreeWalker(
-              document.body,
-              NodeFilter.SHOW_TEXT,
-              {
-                acceptNode: function(node) {
-                  // Skip script and style elements
-                  const parent = node.parentElement;
-                  if (!parent) return NodeFilter.FILTER_REJECT;
-                  
-                  const tagName = parent.tagName.toLowerCase();
-                  if (['script', 'style', 'noscript'].includes(tagName)) {
-                    return NodeFilter.FILTER_REJECT;
-                  }
-                  
-                  // Skip hidden elements
-                  const style = window.getComputedStyle(parent);
-                  if (style.display === 'none' || style.visibility === 'hidden') {
-                    return NodeFilter.FILTER_REJECT;
-                  }
-                  
-                  // Only include text nodes with meaningful content
-                  const text = node.textContent.trim();
-                  if (text.length === 0) {
-                    return NodeFilter.FILTER_REJECT;
-                  }
-                  
-                  return NodeFilter.FILTER_ACCEPT;
-                }
-              }
-            );
-            
-            const textContent = [];
-            let node;
-            while (node = walker.nextNode()) {
-              const text = node.textContent.trim();
-              if (text) {
-                textContent.push(text);
-              }
-            }
-            
-            return {
-              success: true,
-              content: textContent.join(' '),
-              title: document.title,
-              url: window.location.href
-            };
-          } catch (e) {
-            return {
-              success: false,
-              error: e.message || String(e)
-            };
-          }
-        },
-      });
-      
-      if (error) {
-        throw new Error('Script execution failed: ' + error);
-      }
+      await ensureContentScript(targetTab.id);
       
-      const parsedResult = result;
+      const response = await chrome.tabs.sendMessage(targetTab.id, { 
+        type: "getPageContent",
+        data: {
+          includeInteractive: true,
+          includeChanges: true
+        }
+      });
       
-      if (!parsedResult.success) {
-        throw new Error(parsedResult.error || 'Failed to extract page content');
+      if (response && response.success) {
+        // Return the markdown content as extracted by the content script
+        return response.result.content || response.result || '';
       }
       
-      // Return formatted content
-      return `Page Title: ${parsedResult.title}\nURL: ${parsedResult.url}\n\nContent:\n${parsedResult.content}`;
-      
+      throw new Error('Failed to extract page content: No valid response from content script');
     } catch (error) {
       const errorMessage = error instanceof Error ? error.message : String(error);
       console.error('Error in GetPageContentTool:', errorMessage);
@@ -927,46 +854,46 @@ class AskUserQuestionTool extends BrowserTool {
   }
 }
 
-// Simplified page analysis tool using DOM locators
-class GetPageTool extends BrowserTool {
-  constructor() {
-    super(
-      "get_page",
-      "Get page content with role-based element detection. Uses modern DOM locators for better element identification.",
-      z.object({
-        tabId: CommonToolArgs.tabId.optional().describe("Tab ID (optional - will use active tab if not specified)"),
-        mode: z.enum(["text", "interactive", "forms", "all"]).default("all").describe("What to extract from the page"),
-        locators: z.array(z.string()).optional().describe("Specific role-based locators to find (e.g., 'role:button', 'role:textbox', 'label:Email')"),
-        area: z.string().optional().describe("CSS selector to focus on specific area")
-      })
-    );
-  }
-
-  async call({ tabId, mode = "all", locators, area }) {
-    try {
-      const validTabId = await getValidTabId(tabId);
-      
-      await ensureContentScript(validTabId);
-      
-      // Modern approach using role-based queries
-      const command = {
-        type: 'GET_PAGE',
-        data: { mode, locators, area }
-      };
-      
-      const response = await chrome.tabs.sendMessage(validTabId, command);
-      
-      if (response && response.error) {
-        throw new Error(`Get page failed: ${response.error}`);
-      }
-      
-      return response.content || response;
-    } catch (error) {
-      console.error('[AI_AGENT] GetPageTool error:', error);
-      throw new Error(`Get page failed: ${error.message}`);
-    }
-  }
-}
+// // Simplified page analysis tool using DOM locators
+// class GetPageTool extends BrowserTool {
+//   constructor() {
+//     super(
+//       "get_page",
+//       "Get page content with role-based element detection. Uses modern DOM locators for better element identification.",
+//       z.object({
+//         tabId: CommonToolArgs.tabId.optional().describe("Tab ID (optional - will use active tab if not specified)"),
+//         mode: z.enum(["text", "interactive", "forms", "all"]).default("all").describe("What to extract from the page"),
+//         locators: z.array(z.string()).optional().describe("Specific role-based locators to find (e.g., 'role:button', 'role:textbox', 'label:Email')"),
+//         area: z.string().optional().describe("CSS selector to focus on specific area")
+//       })
+//     );
+//   }
+
+//   async call({ tabId, mode = "all", locators, area }) {
+//     try {
+//       const validTabId = await getValidTabId(tabId);
+      
+//       await ensureContentScript(validTabId);
+      
+//       // Modern approach using role-based queries
+//       const command = {
+//         type: 'GET_PAGE',
+//         data: { mode, locators, area }
+//       };
+      
+//       const response = await chrome.tabs.sendMessage(validTabId, command);
+      
+//       if (response && response.error) {
+//         throw new Error(`Get page failed: ${response.error}`);
+//       }
+      
+//       return response.content || response;
+//     } catch (error) {
+//       console.error('[AI_AGENT] GetPageTool error:', error);
+//       throw new Error(`Get page failed: ${error.message}`);
+//     }
+//   }
+// }
 
 // Tool to take a screenshot of the current page with cost-aware options
 class TakeScreenshotTool extends BrowserTool {
@@ -1629,8 +1556,6 @@ class ReflectOnFailureTool extends BrowserTool {
       
       console.log(`ðŸ¤” Reflecting on failed ${failedAction.type} action: ${failedAction.target}`);
       
-      await ensureContentScript(validTabId);
-      
       const response = await chrome.tabs.sendMessage(validTabId, {
         type: 'REFLECT_ON_FAILURE',
         data: { failedAction, contextAnalysis }
@@ -1891,11 +1816,11 @@ export const browserTools = [
   new NavigateToURLTool(),
   
   // Simplified command tools (industry best practices)
-  new ClickTool(),
-  new TypeTool(),
-  new FillTool(),
-  new GetPageTool(),
-  new FindElementTool(),
+  // new ClickTool(),
+  // new TypeTool(),
+  // new FillTool(),
+  // new GetPageTool(),
+  // new FindElementTool(),
   
   // Legacy tools for backward compatibility
   new ClickElementTool(),
@@ -1920,8 +1845,6 @@ export const browserTools = [
   // Verification and intelligence tools
   new VerifyActionTool(),
   new ReflectOnFailureTool(),
-  new ClickElementWithRetryTool(),
-  new FillFormFieldWithRetryTool()
+  // new ClickElementWithRetryTool(),
+  // new FillFormFieldWithRetryTool()
 ];
-
-
diff --git a/chrome/browser/resources/vibe/background.js b/chrome/browser/resources/vibe/background.js
index 865795d7e6..84fa1ad5e8 100644
--- a/chrome/browser/resources/vibe/background.js
+++ b/chrome/browser/resources/vibe/background.js
@@ -274,117 +274,104 @@ async function getAIConfiguration() {
 }
 
 async function getBrowserSettingsViaMessage() {
-  try {
-    // Read settings directly from browser preferences using chrome.settingsPrivate
-    if (chrome.settingsPrivate) {
-      console.log('ðŸ”§ [CONFIG] Reading settings from browser preferences...');
-      
-      // Read Vibe AI preferences directly
-      const preferences = await new Promise((resolve) => {
-        chrome.settingsPrivate.getAllPrefs((prefs) => {
-          resolve(prefs || []);
-        });
+  // Read settings directly from browser preferences using chrome.settingsPrivate
+  if (chrome.settingsPrivate) {
+    console.log('ðŸ”§ [CONFIG] Reading settings from browser preferences...');
+    
+    // Read Vibe AI preferences directly
+    const preferences = await new Promise((resolve) => {
+      chrome.settingsPrivate.getAllPrefs((prefs) => {
+        resolve(prefs || []);
       });
+    });
 
-      // Look for any preferences containing 'vibe' or 'ai'
-      const vibeRelated = preferences.filter(p => 
-        p.key && (p.key.includes('vibe') || p.key.includes('ai'))
-      );
-      console.log('ðŸ” [CONFIG] Vibe/AI related preferences:');
-      vibeRelated.forEach((p, i) => {
-        console.log(`"${p.key}": ${p.value}`);
-      });
-      
-      // Extract Vibe AI settings from preferences
-      const vibePrefs = {};
-      for (const pref of preferences) {
-        if (pref.key && pref.key.startsWith('vibe_ai.')) {
-          vibePrefs[pref.key] = pref.value;
-        }
+    // Look for any preferences containing 'vibe' or 'ai'
+    const vibeRelated = preferences.filter(p => 
+      p.key && (p.key.includes('vibe') || p.key.includes('ai'))
+    );
+    console.log('ðŸ” [CONFIG] Vibe/AI related preferences:');
+    vibeRelated.forEach((p, i) => {
+      console.log(`"${p.key}": ${p.value}`);
+    });
+    
+    // Extract Vibe AI settings from preferences
+    const vibePrefs = {};
+    for (const pref of preferences) {
+      if (pref.key && pref.key.startsWith('vibe_ai.')) {
+        vibePrefs[pref.key] = pref.value;
       }
-      
-      console.log('âœ… [CONFIG] Browser preferences loaded - foundPrefs:', Object.keys(vibePrefs).length);
-      console.log('âœ… [CONFIG] Preference keys found:', Object.keys(vibePrefs));
-      console.log('âœ… [CONFIG] All vibe preferences:', JSON.stringify(vibePrefs, null, 2));
-      console.log('âœ… [CONFIG] hasOpenAIKey:', !!(vibePrefs['vibe_ai.openai_api_key']));
-      console.log('âœ… [CONFIG] openaiKeyLength:', vibePrefs['vibe_ai.openai_api_key'] ? vibePrefs['vibe_ai.openai_api_key'].length : 0);
-      
-      // If no API keys found in preferences, try to trigger environment initialization
-      if (!vibePrefs['vibe_ai.openai_api_key'] && !vibePrefs['vibe_ai.gemini_api_key']) {
-        console.log('ðŸ” [CONFIG] No API keys in preferences, checking environment...');
-        try {
-          // Try to call the settings API to trigger environment initialization
-          const envResponse = await new Promise((resolve, reject) => {
-            chrome.settingsPrivate.defaultZoom = chrome.settingsPrivate.defaultZoom; // Dummy call
-            // This is a workaround - we can't directly call the WebUI handlers from extension
-            // But we can trigger a preference read that might initialize environment
-            setTimeout(() => resolve({}), 100);
-          });
-        } catch (e) {
-          console.log('ðŸ” [CONFIG] Environment initialization attempt failed:', e.message);
-        }
+    }
+    
+    console.log('âœ… [CONFIG] Browser preferences loaded - foundPrefs:', Object.keys(vibePrefs).length);
+    console.log('âœ… [CONFIG] Preference keys found:', Object.keys(vibePrefs));
+    console.log('âœ… [CONFIG] All vibe preferences:', JSON.stringify(vibePrefs, null, 2));
+    console.log('âœ… [CONFIG] hasOpenAIKey:', !!(vibePrefs['vibe_ai.openai_api_key']));
+    console.log('âœ… [CONFIG] openaiKeyLength:', vibePrefs['vibe_ai.openai_api_key'] ? vibePrefs['vibe_ai.openai_api_key'].length : 0);
+    
+    // If no API keys found in preferences, try to trigger environment initialization
+    if (!vibePrefs['vibe_ai.openai_api_key'] && !vibePrefs['vibe_ai.gemini_api_key']) {
+      console.log('ðŸ” [CONFIG] No API keys in preferences, checking environment...');
+      try {
+        // Try to call the settings API to trigger environment initialization
+        const envResponse = await new Promise((resolve, reject) => {
+          chrome.settingsPrivate.defaultZoom = chrome.settingsPrivate.defaultZoom; // Dummy call
+          // This is a workaround - we can't directly call the WebUI handlers from extension
+          // But we can trigger a preference read that might initialize environment
+          setTimeout(() => resolve({}), 100);
+        });
+      } catch (e) {
+        console.log('ðŸ” [CONFIG] Environment initialization attempt failed:', e.message);
       }
-      
-      // Create configuration object based on browser preferences
-      const environmentConfiguration = {
-        openaiConfigured: !!(vibePrefs['vibe_ai.openai_api_key']),
-        geminiConfigured: !!(vibePrefs['vibe_ai.gemini_api_key']),
-        openaiApiKey: vibePrefs['vibe_ai.openai_api_key'] || null,
-        geminiApiKey: vibePrefs['vibe_ai.gemini_api_key'] || null
-      };
-      
-      console.log('ðŸ”§ [CONFIG] Final environment configuration:', JSON.stringify({
-        openaiConfigured: environmentConfiguration.openaiConfigured,
-        geminiConfigured: environmentConfiguration.geminiConfigured,
-        hasOpenaiKey: !!environmentConfiguration.openaiApiKey,
-        hasGeminiKey: !!environmentConfiguration.geminiApiKey
-      }, null, 2));
-      
-      return {
-        provider: vibePrefs['vibe_ai.provider'] || 'auto',
-        model: vibePrefs['vibe_ai.model'] || 'gpt-4o-mini',
-        temperature: vibePrefs['vibe_ai.temperature'] || 0.1,
-        maxTokens: vibePrefs['vibe_ai.max_tokens'] || 128000,
-        agentTimeout: vibePrefs['vibe_ai.agent_timeout'] || 30000,
-        baseUrl: vibePrefs['vibe_ai.base_url'] || null,
-        openaiApiKey: vibePrefs['vibe_ai.openai_api_key'] || null,
-        geminiApiKey: vibePrefs['vibe_ai.gemini_api_key'] || null,
-        environmentConfiguration
-      };
-    } else {
-      console.log('âš ï¸ [CONFIG] chrome.settingsPrivate not available, falling back to storage');
-      
-      // Fallback to storage-based approach
-      const stored = await chrome.storage.local.get([
-        'vibe_browser_settings',
-        'vibe_api_keys'
-      ]);
-      
-      const browserSettings = stored.vibe_browser_settings || {};
-      const apiKeys = stored.vibe_api_keys || {};
-      
-      const environmentConfiguration = {
-        openaiConfigured: !!apiKeys.openai,
-        geminiConfigured: !!apiKeys.gemini,
-        openaiApiKey: apiKeys.openai || null,
-        geminiApiKey: apiKeys.gemini || null
-      };
-      
-      return {
-        ...browserSettings,
-        openaiApiKey: apiKeys.openai || null,
-        geminiApiKey: apiKeys.gemini || null,
-        environmentConfiguration
-      };
     }
-  } catch (error) {
-    console.log('âš ï¸ [CONFIG] Failed to read browser settings:', error.message);
-    return {};
+    
+    // Create configuration object based on browser preferences
+    const environmentConfiguration = {
+      openaiConfigured: !!(vibePrefs['vibe_ai.openai_api_key']),
+      geminiConfigured: !!(vibePrefs['vibe_ai.gemini_api_key']),
+      openaiApiKey: vibePrefs['vibe_ai.openai_api_key'] || null,
+      geminiApiKey: vibePrefs['vibe_ai.gemini_api_key'] || null
+    };
+    
+    console.log('ðŸ”§ [CONFIG] Final environment configuration:', JSON.stringify({
+      openaiConfigured: environmentConfiguration.openaiConfigured,
+      geminiConfigured: environmentConfiguration.geminiConfigured,
+      hasOpenaiKey: !!environmentConfiguration.openaiApiKey,
+      hasGeminiKey: !!environmentConfiguration.geminiApiKey
+    }, null, 2));
+    
+    return {
+      provider: vibePrefs['vibe_ai.provider'] || 'auto',
+      model: vibePrefs['vibe_ai.model'] || 'gpt-4o-mini',
+      temperature: vibePrefs['vibe_ai.temperature'] || 0.1,
+      maxTokens: vibePrefs['vibe_ai.max_tokens'] || 128000,
+      agentTimeout: vibePrefs['vibe_ai.agent_timeout'] || 30000,
+      baseUrl: vibePrefs['vibe_ai.base_url'] || null,
+      openaiApiKey: vibePrefs['vibe_ai.openai_api_key'] || null,
+      geminiApiKey: vibePrefs['vibe_ai.gemini_api_key'] || null,
+      environmentConfiguration
+    };
+  } else {
+    console.log('âš ï¸ [CONFIG] chrome.settingsPrivate not available, using defaults');
+    return {
+      provider: 'auto',
+      model: 'gpt-4o-mini',
+      temperature: 0.1,
+      maxTokens: 128000,
+      agentTimeout: 30000,
+      baseUrl: null,
+      openaiApiKey: null,
+      geminiApiKey: null,
+      environmentConfiguration: {
+        openaiConfigured: false,
+        geminiConfigured: false,
+        openaiApiKey: null,
+        geminiApiKey: null
+      }
+    };
   }
 }
 
 
-
 // Extension installation
 chrome.runtime.onInstalled.addListener(async () => {
   console.log('ðŸš€ Vibe AI Agent extension installed');
@@ -899,4 +886,4 @@ function handleChatHistoryRequest(message, sendResponse) {
   });
 }
 
-console.log('âœ… [BACKGROUND] Background script initialization complete');
\ No newline at end of file
+console.log('âœ… [BACKGROUND] Background script initialization complete');
diff --git a/chrome/browser/resources/vibe/combineMarkdownWithControls.test.js b/chrome/browser/resources/vibe/combineMarkdownWithControls.test.js
new file mode 100644
index 0000000000..f7bdfc4f86
--- /dev/null
+++ b/chrome/browser/resources/vibe/combineMarkdownWithControls.test.js
@@ -0,0 +1,663 @@
+// Unit tests for combineMarkdownWithControls function
+// @ts-nocheck
+
+// Mock DOM environment for testing
+global.document = {
+  getElementById: () => null,
+  querySelector: () => null,
+  body: {}
+};
+
+global.window = {};
+global.Node = {
+  TEXT_NODE: 3,
+  ELEMENT_NODE: 1,
+  DOCUMENT_POSITION_FOLLOWING: 4
+};
+
+// Test runner setup
+console.log('Running combineMarkdownWithControls tests...\n');
+
+// Simple test runner (since we don't have Jest)
+const tests = [];
+let currentDescribe = '';
+let currentTest = '';
+
+global.describe = (name, fn) => {
+  currentDescribe = name;
+  fn();
+};
+
+global.test = (name, fn) => {
+  currentTest = name;
+  try {
+    fn();
+    console.log(`âœ… ${currentDescribe} - ${name}`);
+  } catch (error) {
+    console.log(`âŒ ${currentDescribe} - ${name}`);
+    console.log(`   Error: ${error.message}`);
+  }
+};
+
+global.expect = (actual) => ({
+  toBe: (expected) => {
+    if (actual !== expected) {
+      throw new Error(`Expected "${expected}" but got "${actual}"`);
+    }
+  },
+  toContain: (expected) => {
+    if (!actual || !actual.includes(expected)) {
+      throw new Error(`Expected "${actual}" to contain "${expected}"`);
+    }
+  }
+});
+
+global.beforeEach = (fn) => {
+  // Simple implementation for our tests
+  fn();
+};
+
+// Import the function to test (we'll need to extract it from content.js)
+// For now, let's define it inline for testing
+function combineMarkdownWithControls(markdownContent, interactiveElements) {
+  if (!interactiveElements || interactiveElements.length === 0) {
+    return markdownContent;
+  }
+
+  // Create a map of interactive elements by their position in the DOM
+  const elementMap = new Map();
+  
+  interactiveElements.forEach(element => {
+    try {
+      // Find the actual DOM element to get its position
+      let domElement = null;
+      if (element.id) {
+        domElement = document.getElementById(element.id);
+      } else if (element.name) {
+        domElement = document.querySelector(`[name="${element.name}"]`);
+      } else if (element.selector) {
+        domElement = document.querySelector(element.selector);
+      }
+      
+      if (domElement) {
+        // Find the closest text node or heading to insert near
+        let insertPoint = findNearestTextInsertionPoint(domElement);
+        if (insertPoint) {
+          if (!elementMap.has(insertPoint)) {
+            elementMap.set(insertPoint, []);
+          }
+          elementMap.get(insertPoint).push(element);
+        }
+      }
+    } catch (e) {
+      // Ignore elements we can't find
+    }
+  });
+
+  // If we couldn't map elements to positions, fall back to inline insertion
+  if (elementMap.size === 0) {
+    return insertElementsInlineByContext(markdownContent, interactiveElements);
+  }
+
+  // Insert elements at their natural positions in the content
+  let result = markdownContent;
+  
+  // Sort insertion points by their position in the document
+  const sortedInsertPoints = Array.from(elementMap.keys()).sort((a, b) => {
+    const aPos = a.compareDocumentPosition(b);
+    return aPos & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
+  });
+
+  // Insert elements from bottom to top to avoid position shifting
+  for (let i = sortedInsertPoints.length - 1; i >= 0; i--) {
+    const insertPoint = sortedInsertPoints[i];
+    const elements = elementMap.get(insertPoint);
+    
+    // Create HTML for all elements near this insertion point
+    const elementsHtml = elements.map(element => {
+      const htmlElement = element.html || element.outerHTML ||
+        `<${element.tagName || element.type || 'input'}${element.type ? ` type="${element.type}"` : ''}${element.name ? ` name="${element.name}"` : ''}${element.id ? ` id="${element.id}"` : ''}${element.placeholder ? ` placeholder="${element.placeholder}"` : ''}${element.value ? ` value="${element.value}"` : ''}>`;
+      
+      return htmlElement;
+    }).join(' ');
+    
+    // Find the text in markdown that corresponds to this insertion point
+    const nearbyText = insertPoint.textContent?.trim();
+    if (nearbyText && result.includes(nearbyText)) {
+      // Insert elements after the related text
+      result = result.replace(nearbyText, nearbyText + ' ' + elementsHtml);
+    }
+  }
+
+  return result;
+}
+
+/**
+ * Find the nearest text node or heading where we should insert form elements
+ */
+function findNearestTextInsertionPoint(element) {
+  // Look for parent elements that might have meaningful text
+  let current = element.parentElement;
+  while (current && current !== document.body) {
+    // Check if this element has meaningful text (not just the input)
+    const textContent = Array.from(current.childNodes)
+      .filter(node => node.nodeType === Node.TEXT_NODE || 
+                     (node.nodeType === Node.ELEMENT_NODE && 
+                      !['INPUT', 'TEXTAREA', 'SELECT', 'BUTTON'].includes(node.tagName)))
+      .map(node => node.textContent?.trim())
+      .filter(text => text && text.length > 3)
+      .join(' ');
+    
+    if (textContent) {
+      return current;
+    }
+    current = current.parentElement;
+  }
+  
+  return element.parentElement || element;
+}
+
+/**
+ * Insert elements inline based on context matching
+ */
+function insertElementsInlineByContext(markdownContent, interactiveElements) {
+  let result = markdownContent;
+  
+  interactiveElements.forEach(element => {
+    // Create HTML representation
+    const tagName = element.tagName || (element.type === 'submit' ? 'button' : 'input');
+    const htmlElement = element.html || element.outerHTML ||
+      `<${tagName}${element.type ? ` type="${element.type}"` : ''}${element.name ? ` name="${element.name}"` : ''}${element.id ? ` id="${element.id}"` : ''}${element.placeholder ? ` placeholder="${element.placeholder}"` : ''}${element.value ? ` value="${element.value}"` : ''}>`;
+    
+    // Try to find contextual clues to insert the element
+    const contextClues = [];
+    
+    if (element.placeholder) {
+      contextClues.push(element.placeholder);
+    }
+    if (element.context) {
+      // Extract meaningful words from context
+      const contextWords = element.context.split(/[:|,]/)
+        .map(part => part.trim())
+        .filter(part => part.length > 3);
+      contextClues.push(...contextWords);
+    }
+    
+    // Try to find a good insertion point based on context
+    let inserted = false;
+    for (const clue of contextClues) {
+      // Look for headings or labels that match this context
+      const patterns = [
+        new RegExp(`(#{1,6}\\s*.*${clue}.*\\n)`, 'gi'),
+        new RegExp(`(.*${clue}.*:?\\s*)\\n`, 'gi'),
+        new RegExp(`(\\*\\*.*${clue}.*\\*\\*:?\\s*)`, 'gi')
+      ];
+      
+      for (const pattern of patterns) {
+        if (pattern.test(result)) {
+          result = result.replace(pattern, `$1 ${htmlElement}\n`);
+          inserted = true;
+          break;
+        }
+      }
+      if (inserted) break;
+    }
+    
+    // If we couldn't find a good context match, add at the end of relevant sections
+    if (!inserted) {
+      // Try to find form-related sections
+      const formSections = result.match(/#{1,6}.*(?:form|search|input|fill).*\n/gi);
+      if (formSections && formSections.length > 0) {
+        const lastFormSection = formSections[formSections.length - 1];
+        result = result.replace(lastFormSection, lastFormSection + htmlElement + '\n');
+      } else {
+        // Just add after the first heading
+        result = result.replace(/^(#{1,6}.*\n)/, `$1${htmlElement}\n`);
+      }
+    }
+  });
+
+  return result;
+}
+
+describe('combineMarkdownWithControls', () => {
+  describe('when no interactive elements provided', () => {
+    test('should return original markdown unchanged when elements array is empty', () => {
+      const markdown = '# Test Page\n\nSome content here.';
+      const result = combineMarkdownWithControls(markdown, []);
+      
+      expect(result).toBe(markdown);
+    });
+
+    test('should return original markdown unchanged when elements is null', () => {
+      const markdown = '# Test Page\n\nSome content here.';
+      const result = combineMarkdownWithControls(markdown, null);
+      
+      expect(result).toBe(markdown);
+    });
+
+    test('should return original markdown unchanged when elements is undefined', () => {
+      const markdown = '# Test Page\n\nSome content here.';
+      const result = combineMarkdownWithControls(markdown, undefined);
+      
+      expect(result).toBe(markdown);
+    });
+  });
+
+  describe('context-based insertion (DOM mapping fails)', () => {
+    beforeEach(() => {
+      // Mock DOM methods to return null (simulate no DOM elements found)
+      document.getElementById = () => null;
+      document.querySelector = () => null;
+    });
+
+    test('should insert input elements after matching headings', () => {
+      const markdown = `# Flight Search
+
+## Departure Information
+From airport
+
+## Destination Information  
+To airport
+
+## Search
+Find flights`;
+
+      const elements = [
+        {
+          type: 'text',
+          name: 'departure_airport',
+          placeholder: 'Where from?',
+          context: 'From airport'
+        },
+        {
+          type: 'text', 
+          name: 'destination_airport',
+          placeholder: 'Where to?',
+          context: 'To airport'
+        },
+        {
+          type: 'submit',
+          name: 'search_button',
+          context: 'Find flights'
+        }
+      ];
+
+      const result = combineMarkdownWithControls(markdown, elements);
+      
+      // Check that elements are inserted after related headings/text
+      expect(result).toContain('From airport <input type="text" name="departure_airport" placeholder="Where from?">');
+      expect(result).toContain('To airport <input type="text" name="destination_airport" placeholder="Where to?">');
+      expect(result).toContain('Find flights <input type="submit" name="search_button">');
+    });
+
+    test('should handle elements with placeholder-based context matching', () => {
+      const markdown = `# Login Form
+
+## Credentials
+Enter your email
+Enter your password
+
+## Actions
+Submit form`;
+
+      const elements = [
+        {
+          type: 'email',
+          name: 'email',
+          placeholder: 'Enter your email'
+        },
+        {
+          type: 'password',
+          name: 'password', 
+          placeholder: 'Enter your password'
+        }
+      ];
+
+      const result = combineMarkdownWithControls(markdown, elements);
+      
+      expect(result).toContain('Enter your email <input type="email" name="email" placeholder="Enter your email">');
+      expect(result).toContain('Enter your password <input type="password" name="password" placeholder="Enter your password">');
+    });
+
+    test('should handle elements with complex context parsing', () => {
+      const markdown = `# User Registration
+
+## Personal Information
+First Name: Required field
+Last Name: Required field
+
+## Account Details
+Email Address: Must be valid`;
+
+      const elements = [
+        {
+          type: 'text',
+          name: 'first_name',
+          context: 'Label: First Name, Before: Required field'
+        },
+        {
+          type: 'text',
+          name: 'last_name', 
+          context: 'Label: Last Name, Before: Required field'
+        },
+        {
+          type: 'email',
+          name: 'email',
+          context: 'Label: Email Address, After: Must be valid'
+        }
+      ];
+
+      const result = combineMarkdownWithControls(markdown, elements);
+      
+      expect(result).toContain('First Name <input type="text" name="first_name">');
+      expect(result).toContain('Last Name <input type="text" name="last_name">');
+      expect(result).toContain('Email Address <input type="email" name="email">');
+    });
+
+    test('should handle elements without good context matches by adding to form sections', () => {
+      const markdown = `# Contact Form
+
+## Basic Information
+Some general info about the form.
+
+## Submit
+Ready to send your message?`;
+
+      const elements = [
+        {
+          type: 'text',
+          name: 'mystery_field',
+          // No context or placeholder that matches the markdown
+        }
+      ];
+
+      const result = combineMarkdownWithControls(markdown, elements);
+      
+      // Should add after the form section heading
+      expect(result).toContain('# Contact Form\n<input type="text" name="mystery_field">\n');
+    });
+
+    test('should preserve all HTML attributes in output', () => {
+      const markdown = `# Test Form
+Username field`;
+
+      const elements = [
+        {
+          type: 'text',
+          name: 'username',
+          id: 'user-input',
+          placeholder: 'Enter username',
+          value: 'default_user',
+          context: 'Username field'
+        }
+      ];
+
+      const result = combineMarkdownWithControls(markdown, elements);
+      
+      expect(result).toContain('<input type="text" name="username" id="user-input" placeholder="Enter username" value="default_user">');
+    });
+
+    test('should handle elements with pre-built HTML', () => {
+      const markdown = `# Custom Form
+Special input field`;
+
+      const elements = [
+        {
+          html: '<input type="date" name="custom_date" class="fancy-input" required>',
+          context: 'Special input field'
+        }
+      ];
+
+      const result = combineMarkdownWithControls(markdown, elements);
+      
+      expect(result).toContain('Special input field <input type="date" name="custom_date" class="fancy-input" required>');
+    });
+
+    test('should handle multiple elements with same context', () => {
+      const markdown = `# Flight Search
+Departure details
+Arrival details`;
+
+      const elements = [
+        {
+          type: 'text',
+          name: 'departure_city',
+          context: 'Departure details'
+        },
+        {
+          type: 'date', 
+          name: 'departure_date',
+          context: 'Departure details'
+        }
+      ];
+
+      const result = combineMarkdownWithControls(markdown, elements);
+      
+      // Both elements should be inserted after the same context
+      expect(result).toContain('Departure details <input type="text" name="departure_city"> <input type="date" name="departure_date">');
+    });
+
+    test('should handle various element types correctly', () => {
+      const markdown = `# Form Elements
+Text input
+Number input  
+Select dropdown
+Text area
+Submit button`;
+
+      const elements = [
+        {
+          type: 'text',
+          name: 'text_field',
+          context: 'Text input'
+        },
+        {
+          type: 'number',
+          name: 'number_field',
+          context: 'Number input'
+        },
+        {
+          tagName: 'select',
+          name: 'dropdown',
+          context: 'Select dropdown'
+        },
+        {
+          tagName: 'textarea',
+          name: 'text_area',
+          context: 'Text area'
+        },
+        {
+          tagName: 'button',
+          type: 'submit',
+          context: 'Submit button'
+        }
+      ];
+
+      const result = combineMarkdownWithControls(markdown, elements);
+      
+      expect(result).toContain('<input type="text" name="text_field">');
+      expect(result).toContain('<input type="number" name="number_field">');
+      expect(result).toContain('<select name="dropdown">');
+      expect(result).toContain('<textarea name="text_area">');
+      expect(result).toContain('<button type="submit">');
+    });
+  });
+
+  describe('edge cases and error handling', () => {
+    test('should handle empty markdown gracefully', () => {
+      const markdown = '';
+      const elements = [
+        {
+          type: 'text',
+          name: 'test_field'
+        }
+      ];
+
+      const result = combineMarkdownWithControls(markdown, elements);
+      
+      // Should not crash and should still contain the element
+      expect(result).toContain('<input type="text" name="test_field">');
+    });
+
+    test('should handle elements with missing properties', () => {
+      const markdown = '# Test\nSome content';
+      const elements = [
+        {
+          // Missing type, name, etc.
+        },
+        {
+          name: 'valid_field',
+          type: 'text'
+        }
+      ];
+
+      const result = combineMarkdownWithControls(markdown, elements);
+      
+      // Should not crash and should handle the valid element
+      expect(result).toContain('<input type="text" name="valid_field">');
+    });
+
+    test('should handle special characters in context and values', () => {
+      const markdown = `# Special Characters
+Field with "quotes" and <brackets>`;
+
+      const elements = [
+        {
+          type: 'text',
+          name: 'special_field',
+          placeholder: 'Enter "quoted" value',
+          context: 'Field with "quotes" and <brackets>'
+        }
+      ];
+
+      const result = combineMarkdownWithControls(markdown, elements);
+      
+      expect(result).toContain('placeholder="Enter &quot;quoted&quot; value"');
+    });
+  });
+
+  describe('real-world scenarios', () => {
+    test('should handle a complete flight search form', () => {
+      const markdown = `# Flight Search
+
+## Trip Details
+Plan your journey
+
+From: Select departure airport
+To: Choose your destination  
+Departure: Pick departure date
+Return: Select return date (optional)
+
+## Passengers
+Number of travelers: Choose passenger count
+
+## Search
+Find the best flights for your trip`;
+
+      const elements = [
+        {
+          type: 'text',
+          name: 'departure_airport',
+          placeholder: 'Where from?',
+          context: 'From: Select departure airport'
+        },
+        {
+          type: 'text',
+          name: 'destination_airport', 
+          placeholder: 'Where to?',
+          context: 'To: Choose your destination'
+        },
+        {
+          type: 'date',
+          name: 'departure_date',
+          context: 'Departure: Pick departure date'
+        },
+        {
+          type: 'date',
+          name: 'return_date',
+          context: 'Return: Select return date (optional)'
+        },
+        {
+          type: 'number',
+          name: 'passengers',
+          value: '1',
+          context: 'Number of travelers: Choose passenger count'
+        },
+        {
+          type: 'submit',
+          name: 'search_flights',
+          context: 'Find the best flights for your trip'
+        }
+      ];
+
+      const result = combineMarkdownWithControls(markdown, elements);
+
+      expect(result).toContain('From: Select departure airport <input type="text" name="departure_airport" placeholder="Where from?">');
+      expect(result).toContain('To: Choose your destination <input type="text" name="destination_airport" placeholder="Where to?">');
+      expect(result).toContain('Departure: Pick departure date <input type="date" name="departure_date">');
+      expect(result).toContain('Return: Select return date (optional) <input type="date" name="return_date">');
+      expect(result).toContain('Number of travelers: Choose passenger count <input type="number" name="passengers" value="1">');
+      expect(result).toContain('Find the best flights for your trip <input type="submit" name="search_flights">');
+    });
+
+    test('should handle a login form scenario', () => {
+      const markdown = `# User Login
+
+Welcome back! Please sign in to your account.
+
+## Credentials
+Email: Enter your registered email address
+Password: Enter your account password
+
+## Options
+Remember me on this device
+
+## Sign In
+Access your account`;
+
+      const elements = [
+        {
+          type: 'email',
+          name: 'email', 
+          id: 'login-email',
+          placeholder: 'you@example.com',
+          context: 'Email: Enter your registered email address'
+        },
+        {
+          type: 'password',
+          name: 'password',
+          id: 'login-password', 
+          context: 'Password: Enter your account password'
+        },
+        {
+          type: 'checkbox',
+          name: 'remember_me',
+          context: 'Remember me on this device'
+        },
+        {
+          type: 'submit',
+          name: 'login_submit',
+          context: 'Access your account'
+        }
+      ];
+
+      const result = combineMarkdownWithControls(markdown, elements);
+
+      expect(result).toContain('Email: Enter your registered email address <input type="email" name="email" id="login-email" placeholder="you@example.com">');
+      expect(result).toContain('Password: Enter your account password <input type="password" name="password" id="login-password">');
+      expect(result).toContain('Remember me on this device <input type="checkbox" name="remember_me">');
+      expect(result).toContain('Access your account <input type="submit" name="login_submit">');
+    });
+  });
+});
+
+
+// Export for potential external use
+if (typeof module !== 'undefined' && module.exports) {
+  module.exports = {
+    combineMarkdownWithControls,
+    insertElementsInlineByContext,
+    findNearestTextInsertionPoint
+  };
+}
diff --git a/chrome/browser/resources/vibe/content.js b/chrome/browser/resources/vibe/content.js
index 87013be00f..5aa6782a54 100644
--- a/chrome/browser/resources/vibe/content.js
+++ b/chrome/browser/resources/vibe/content.js
@@ -905,7 +905,17 @@ async function fillInput(selector, value) {
   const originalValue = element.value;
   
   try {
-    // Set the value
+    // Clear the existing value first to avoid concatenation
+    element.value = "";
+    
+    // Dispatch events to notify about clearing
+    element.dispatchEvent(new Event("input", { bubbles: true }));
+    element.dispatchEvent(new Event("change", { bubbles: true }));
+    
+    // Small delay to ensure clearing is processed
+    await new Promise(resolve => setTimeout(resolve, 50));
+    
+    // Now set the new value
     element.value = value;
     
     // Dispatch comprehensive events to trigger any JS handlers
@@ -1225,8 +1235,64 @@ function isElementVisible(element) {
 function handleElementClick(data) {
   console.log("ðŸ‘† Clicking element:", JSON.stringify(data));
 
-  // Use deep selector to pierce Shadow DOM
-  const element = querySelectorDeep(document, data.selector);
+  // Define fallback selectors for common patterns
+  const fallbackSelectors = [];
+  
+  // Special handling for Google Flights search button
+  if (data.selector.includes('Search flights')) {
+    fallbackSelectors.push(
+      'button[aria-label="Search"]',
+      'button[aria-label="Search for flights"]',
+      'button[jsname*="search"]',
+      'button[data-test-id="search-button"]',
+      'button:contains("Search")',
+      'div[role="button"][aria-label*="Search"]',
+      'span:contains("Search"):parent',
+      // Google Flights specific patterns
+      'button.VfPpkd-LgbsSe[jsname="vLv7Lb"]',
+      'div[data-flt-ve="search_button"]',
+      'button.gws-flights-form__search-button'
+    );
+  }
+  
+  // Try original selector first
+  let element = querySelectorDeep(document, data.selector);
+  
+  // Try fallback selectors if original fails
+  if (!element && fallbackSelectors.length > 0) {
+    console.log(`ðŸ”„ Trying ${fallbackSelectors.length} fallback selectors...`);
+    for (const fallback of fallbackSelectors) {
+      try {
+        element = querySelectorDeep(document, fallback);
+        if (element) {
+          console.log(`âœ… Found element with fallback selector: ${fallback}`);
+          break;
+        }
+      } catch (e) {
+        // Some selectors might throw errors, continue to next
+      }
+    }
+  }
+  
+  // Final attempt: check if Google Flights auto-submitted (no button needed)
+  if (!element && data.selector.includes('Search flights')) {
+    // Check if results are already visible
+    const resultsIndicators = [
+      '.gws-flights-results__result-list',
+      '[data-flt-ve="results_list"]',
+      '.gws-flights__results',
+      'div[aria-label*="flight results"]'
+    ];
+    
+    for (const indicator of resultsIndicators) {
+      const results = document.querySelector(indicator);
+      if (results) {
+        console.log(`âœ… Search already executed - results are visible`);
+        return { success: true, message: `Search already executed - results visible` };
+      }
+    }
+  }
+  
   if (element) {
     // Scroll element into view to avoid overlay issues
     element.scrollIntoView({ block: 'center', behavior: 'smooth' });
@@ -1241,6 +1307,18 @@ function handleElementClick(data) {
   } else {
     const errorMessage = `Could not find element to click: ${data.selector}`;
     console.log(`âŒ ${errorMessage}`);
+    
+    // Provide helpful debugging info
+    const buttons = document.querySelectorAll('button');
+    console.log(`ðŸ“Š Found ${buttons.length} buttons on page`);
+    if (buttons.length > 0) {
+      console.log(`ðŸ” First 5 buttons:`, Array.from(buttons).slice(0, 5).map(btn => ({
+        text: btn.textContent?.trim(),
+        ariaLabel: btn.getAttribute('aria-label'),
+        className: btn.className
+      })));
+    }
+    
     throw new Error(errorMessage);
   }
 }
@@ -2004,30 +2082,166 @@ function getInputContext(input) {
 }
 
 /**
- * Combine markdown content with interactive controls
+ * Combine markdown content with interactive controls mixed inline
  */
 function combineMarkdownWithControls(markdownContent, interactiveElements) {
-  let combinedContent = markdownContent;
-
-  // If we have interactive elements, add them as a section
-  if (interactiveElements && interactiveElements.length > 0) {
-    combinedContent += '\n\n## Interactive Elements\n\n';
+  if (!interactiveElements || interactiveElements.length === 0) {
+    return markdownContent;
+  }
 
-    interactiveElements.forEach((element, index) => {
-      // Add context as markdown comment if available
-      if (element.context) {
-        combinedContent += `<!-- Context: ${element.context} -->\n`;
+  // Create a map of interactive elements by their position in the DOM
+  const elementMap = new Map();
+  
+  interactiveElements.forEach(element => {
+    try {
+      // Find the actual DOM element to get its position
+      let domElement = null;
+      if (element.id) {
+        domElement = document.getElementById(element.id);
+      } else if (element.name) {
+        domElement = document.querySelector(`[name="${element.name}"]`);
+      } else if (element.selector) {
+        domElement = document.querySelector(element.selector);
       }
+      
+      if (domElement) {
+        // Find the closest text node or heading to insert near
+        let insertPoint = findNearestTextInsertionPoint(domElement);
+        if (insertPoint) {
+          if (!elementMap.has(insertPoint)) {
+            elementMap.set(insertPoint, []);
+          }
+          elementMap.get(insertPoint).push(element);
+        }
+      }
+    } catch (e) {
+      // Ignore elements we can't find
+    }
+  });
 
-      // Add the HTML element
+  // If we couldn't map elements to positions, fall back to inline insertion
+  if (elementMap.size === 0) {
+    return insertElementsInlineByContext(markdownContent, interactiveElements);
+  }
+
+  // Insert elements at their natural positions in the content
+  let result = markdownContent;
+  
+  // Sort insertion points by their position in the document
+  const sortedInsertPoints = Array.from(elementMap.keys()).sort((a, b) => {
+    const aPos = a.compareDocumentPosition(b);
+    return aPos & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
+  });
+
+  // Insert elements from bottom to top to avoid position shifting
+  for (let i = sortedInsertPoints.length - 1; i >= 0; i--) {
+    const insertPoint = sortedInsertPoints[i];
+    const elements = elementMap.get(insertPoint);
+    
+    // Create HTML for all elements near this insertion point
+    const elementsHtml = elements.map(element => {
       const htmlElement = element.html || element.outerHTML ||
-        `<${element.tagName}${element.type ? ` type="${element.type}"` : ''}${element.name ? ` name="${element.name}"` : ''}${element.id ? ` id="${element.id}"` : ''}${element.placeholder ? ` placeholder="${element.placeholder}"` : ''}${element.value ? ` value="${element.value}"` : ''}>`;
+        `<${element.tagName || element.type || 'input'}${element.type ? ` type="${element.type}"` : ''}${element.name ? ` name="${element.name}"` : ''}${element.id ? ` id="${element.id}"` : ''}${element.placeholder ? ` placeholder="${element.placeholder}"` : ''}${element.value ? ` value="${element.value}"` : ''}>`;
+      
+      return htmlElement;
+    }).join(' ');
+    
+    // Find the text in markdown that corresponds to this insertion point
+    const nearbyText = insertPoint.textContent?.trim();
+    if (nearbyText && result.includes(nearbyText)) {
+      // Insert elements after the related text
+      result = result.replace(nearbyText, nearbyText + ' ' + elementsHtml);
+    }
+  }
 
-      combinedContent += htmlElement + '\n\n';
-    });
+  return result;
+}
+
+/**
+ * Find the nearest text node or heading where we should insert form elements
+ */
+function findNearestTextInsertionPoint(element) {
+  // Look for parent elements that might have meaningful text
+  let current = element.parentElement;
+  while (current && current !== document.body) {
+    // Check if this element has meaningful text (not just the input)
+    const textContent = Array.from(current.childNodes)
+      .filter(node => node.nodeType === Node.TEXT_NODE || 
+                     (node.nodeType === Node.ELEMENT_NODE && 
+                      !['INPUT', 'TEXTAREA', 'SELECT', 'BUTTON'].includes(node.tagName)))
+      .map(node => node.textContent?.trim())
+      .filter(text => text && text.length > 3)
+      .join(' ');
+    
+    if (textContent) {
+      return current;
+    }
+    current = current.parentElement;
   }
+  
+  return element.parentElement || element;
+}
+
+/**
+ * Insert elements inline based on context matching
+ */
+function insertElementsInlineByContext(markdownContent, interactiveElements) {
+  let result = markdownContent;
+  
+  interactiveElements.forEach(element => {
+    // Create HTML representation
+    const htmlElement = element.html || element.outerHTML ||
+      `<${element.tagName || element.type || 'input'}${element.type ? ` type="${element.type}"` : ''}${element.name ? ` name="${element.name}"` : ''}${element.id ? ` id="${element.id}"` : ''}${element.placeholder ? ` placeholder="${element.placeholder}"` : ''}${element.value ? ` value="${element.value}"` : ''}>`;
+    
+    // Try to find contextual clues to insert the element
+    const contextClues = [];
+    
+    if (element.placeholder) {
+      contextClues.push(element.placeholder);
+    }
+    if (element.context) {
+      // Extract meaningful words from context
+      const contextWords = element.context.split(/[:|,]/)
+        .map(part => part.trim())
+        .filter(part => part.length > 3);
+      contextClues.push(...contextWords);
+    }
+    
+    // Try to find a good insertion point based on context
+    let inserted = false;
+    for (const clue of contextClues) {
+      // Look for headings or labels that match this context
+      const patterns = [
+        new RegExp(`(#{1,6}\\s*.*${clue}.*\\n)`, 'gi'),
+        new RegExp(`(.*${clue}.*:?\\s*)\\n`, 'gi'),
+        new RegExp(`(\\*\\*.*${clue}.*\\*\\*:?\\s*)`, 'gi')
+      ];
+      
+      for (const pattern of patterns) {
+        if (pattern.test(result)) {
+          result = result.replace(pattern, `$1 ${htmlElement}\n`);
+          inserted = true;
+          break;
+        }
+      }
+      if (inserted) break;
+    }
+    
+    // If we couldn't find a good context match, add at the end of relevant sections
+    if (!inserted) {
+      // Try to find form-related sections
+      const formSections = result.match(/#{1,6}.*(?:form|search|input|fill).*\n/gi);
+      if (formSections && formSections.length > 0) {
+        const lastFormSection = formSections[formSections.length - 1];
+        result = result.replace(lastFormSection, lastFormSection + htmlElement + '\n');
+      } else {
+        // Just add after the first heading
+        result = result.replace(/^(#{1,6}.*\n)/, `$1${htmlElement}\n`);
+      }
+    }
+  });
 
-  return combinedContent;
+  return result;
 }
 
 /**
-- 
2.50.0

