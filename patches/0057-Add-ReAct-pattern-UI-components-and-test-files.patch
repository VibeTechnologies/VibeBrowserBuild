From 78df4dd636cdb6c6cb1bfcf02a0114460acfc443 Mon Sep 17 00:00:00 2001
From: Den <2119348+dzianisv@users.noreply.github.com>
Date: Sun, 27 Jul 2025 16:02:09 +0300
Subject: [PATCH 057/107] Add ReAct pattern UI components and test files

- Add ReActStep.tsx component for displaying reasoning steps
- Update ChatPage.tsx and Message.tsx for better ReAct integration
- Add comprehensive test files for agent logging and reasoning flow
- Update CLAUDE.md with additional build and test instructions
- Enhance background.js and content.js for better extension integration
---
 chrome/browser/resources/vibe/CLAUDE.md       |   3 +-
 .../resources/vibe/ai_tools.extension.js      | 445 ++----------------
 .../chat4/src/components/chat/ChatPage.tsx    |  42 +-
 .../chat4/src/components/chat/Message.tsx     |  29 ++
 .../chat4/src/components/chat/ReActStep.tsx   | 146 ++++++
 .../vibe/apps/chat4/src/utils/aiAgent.ts      |  38 ++
 chrome/browser/resources/vibe/background.js   |  26 +-
 chrome/browser/resources/vibe/content.js      |   2 -
 .../resources/vibe/test_agent_logging.js      |  35 ++
 .../resources/vibe/test_reasoning_flow.js     |  46 ++
 .../vibe/trigger_reasoning_test.html          |  25 +
 11 files changed, 436 insertions(+), 401 deletions(-)
 create mode 100644 chrome/browser/resources/vibe/apps/chat4/src/components/chat/ReActStep.tsx
 create mode 100644 chrome/browser/resources/vibe/test_agent_logging.js
 create mode 100644 chrome/browser/resources/vibe/test_reasoning_flow.js
 create mode 100644 chrome/browser/resources/vibe/trigger_reasoning_test.html

diff --git a/chrome/browser/resources/vibe/CLAUDE.md b/chrome/browser/resources/vibe/CLAUDE.md
index 8e9bccabb0..932934a82c 100644
--- a/chrome/browser/resources/vibe/CLAUDE.md
+++ b/chrome/browser/resources/vibe/CLAUDE.md
@@ -4,4 +4,5 @@ Browser consist of small Chromium patches and this component extension that is b
 Put all the documentation about implementation inside docs/ai
 Read docs in docs/ before starting perfoming tasks
 Before starting work on the task, decompose task into smaller task. Plan it.
-
+To build browser with the extension, run `ninja -C out/Debug chrome`
+DO NOT WRITE YOUR OWN TEST SCRIPT IF NOT ASKED DIRECTLY. USE ./test_vibe.sh. It bulds a debug chrome, launch it, type in query. You have to investigate logs and check screenshots it creates in ./.test directory.
diff --git a/chrome/browser/resources/vibe/ai_tools.extension.js b/chrome/browser/resources/vibe/ai_tools.extension.js
index 6087f247a6..2b0849c266 100644
--- a/chrome/browser/resources/vibe/ai_tools.extension.js
+++ b/chrome/browser/resources/vibe/ai_tools.extension.js
@@ -165,102 +165,73 @@ class FinishTool extends BrowserTool {
   }
 }
 
-// Enhanced Reasoning tool for LLM to express thoughts and manage task state with graph annotation
-class ReasoningTool extends BrowserTool {
+// ReAct Pattern Tools: Thought, Action, Observation
+
+// Thought tool - for expressing reasoning before actions
+class ThoughtTool extends BrowserTool {
   constructor() {
     super(
-      "reasoning",
-      "Use this tool to express your thoughts, analysis, and reasoning about the current situation. Can also annotate the mind-map graph with new nodes and relationships.",
+      "thought",
+      "Express your reasoning, planning, and analysis before taking action. Use this to think through what you want to accomplish.",
       z.object({
-        thinking: z.string().describe("Your current thoughts and analysis"),
-        evaluation: z.string().describe("Evaluation of previous actions or current state"),
-        next_goal: z.string().describe("What you plan to do next"),
-        memory: z.object({}).passthrough().optional().describe("Important information to remember"),
-        task_completed: z.boolean().optional().describe("Set to true when the user's task is fully completed"),
-        confidence: z.number().min(0).max(1).optional().describe("Confidence level in current approach (0-1)"),
-        completed_steps: z.array(z.string()).optional().describe("List of steps completed so far"),
-        graph_annotations: z.object({
-          add_node: z.object({
-            type: z.enum(["observation", "tool_output", "reasoning", "goal"]).describe("Type of node to add"),
-            content: z.string().describe("Content of the node"),
-            metadata: z.object({}).passthrough().optional().describe("Additional metadata")
-          }).optional().describe("Add a new node to the mind-map"),
-          add_edge: z.object({
-            from_content: z.string().describe("Content to identify the source node"),
-            to_content: z.string().describe("Content to identify the target node"),
-            relationship: z.enum(["caused_by", "leads_to", "related_to", "depends_on"]).describe("Type of relationship")
-          }).optional().describe("Add a relationship between existing nodes")
-        }).optional().describe("Graph annotations to update the mind-map")
+        reasoning: z.string().describe("Your thoughts and reasoning about the current situation"),
+        plan: z.string().describe("What you plan to do next and why"),
+        confidence: z.number().min(0).max(1).optional().describe("Confidence level in your plan (0-1)")
       })
     );
-    
-    // Initialize memory manager for graph operations
-    this.memoryManager = new MemoryManager();
   }
   
-  async call({ thinking, evaluation, next_goal, memory, task_completed, confidence, completed_steps, graph_annotations }) {
+  async call({ reasoning, plan, confidence }) {
     const response = {
-      thinking,
-      evaluation,
-      next_goal,
-      task_completed: task_completed || false,
-      confidence: confidence || 0.5,
+      type: "thought",
+      reasoning,
+      plan,
+      confidence: confidence || 0.8,
       timestamp: new Date().toISOString()
     };
     
-    // Handle graph annotations if provided
-    if (graph_annotations) {
-      try {
-        if (graph_annotations.add_node) {
-          const node = await this.memoryManager.addNode(
-            graph_annotations.add_node.type,
-            graph_annotations.add_node.content,
-            graph_annotations.add_node.metadata || {}
-          );
-          response.graph_node_added = node.id;
-          console.log(`🧠 [REASONING] Added mind-map node: ${node.id}`);
-        }
-        
-        if (graph_annotations.add_edge) {
-          // Find nodes by content matching
-          const fromNodes = await this.memoryManager.searchNodes(graph_annotations.add_edge.from_content);
-          const toNodes = await this.memoryManager.searchNodes(graph_annotations.add_edge.to_content);
-          
-          if (fromNodes.length > 0 && toNodes.length > 0) {
-            const edge = await this.memoryManager.addEdge(
-              fromNodes[0].id,
-              toNodes[0].id,
-              graph_annotations.add_edge.relationship
-            );
-            response.graph_edge_added = edge.id;
-            console.log(`🧠 [REASONING] Added mind-map edge: ${edge.id}`);
-          } else {
-            console.warn(`⚠️ [REASONING] Could not find nodes for edge creation`);
-          }
-        }
-      } catch (graphError) {
-        console.error(`❌ [REASONING] Graph annotation failed:`, graphError);
-        response.graph_error = graphError.message;
-      }
-    }
+    console.log(`🤔 [THOUGHT] ${reasoning}`);
+    console.log(`📋 [PLAN] ${plan}`);
     
-    if (memory) {
-      response.memory = memory;
-    }
-    
-    if (completed_steps) {
-      response.completed_steps = completed_steps;
-    }
+    return response;
+  }
+}
+
+// Observation tool - for analyzing results after actions
+class ObservationTool extends BrowserTool {
+  constructor() {
+    super(
+      "observation",
+      "Analyze and reflect on the results of your previous action. Use this to understand what happened and plan next steps.",
+      z.object({
+        analysis: z.string().describe("Analysis of what happened in the previous action"),
+        outcome: z.enum(["success", "partial", "failure", "unexpected"]).describe("How would you classify the outcome"),
+        next_step: z.string().describe("What you should do next based on this observation"),
+        learned: z.string().optional().describe("What you learned from this action")
+      })
+    );
+  }
+  
+  async call({ analysis, outcome, next_step, learned }) {
+    const response = {
+      type: "observation",
+      analysis,
+      outcome,
+      next_step,
+      learned,
+      timestamp: new Date().toISOString()
+    };
     
-    // Log task completion for debugging
-    if (task_completed) {
-      console.log(`🎯 [AI_AGENT] Task marked as completed by reasoning tool`);
-    }
+    console.log(`👁️ [OBSERVATION] ${analysis}`);
+    console.log(`📊 [OUTCOME] ${outcome}`);
+    console.log(`➡️ [NEXT] ${next_step}`);
     
     return response;
   }
 }
 
+// ReasoningTool removed - replaced by ThoughtTool and ObservationTool for clean ReAct pattern
+
 // DOM-related tools
 class GetDomStructureTool extends BrowserTool {
   constructor() {
@@ -518,37 +489,6 @@ class CreateNewTabTool extends BrowserTool {
   }
 }
 
-// not used
-class ExtractReadableContentTool extends BrowserTool {
-  constructor() {
-    super(
-      "extract_readable_content",
-      "Extract the main readable content (article) from the current web page.",
-      z.object({
-        tabId: CommonToolArgs.tabId
-      })
-    );
-  }
-  async call({ tabId }) {
-    // Inject and execute extractReadableContent in the page context
-    const [{ result, error }] = await chrome.scripting.executeScript({
-      target: { tabId },
-      func: () => {
-        try {
-          if (typeof extractReadableContent !== 'function') {
-            throw new Error('extractReadableContent is not defined on the page.');
-          }
-          return { result: extractReadableContent() };
-        } catch (e) {
-          return { error: e.message || String(e) };
-        }
-      },
-    });
-    if (error) throw new Error('Content extraction failed: ' + error);
-    if (!result) throw new Error('No readable content found.');
-    return result;
-  }
-}
 
 class NavigateToURLTool extends BrowserTool {
   constructor() {
@@ -1586,280 +1526,7 @@ class VerifyActionTool extends BrowserTool {
   }
 }
 
-// Tool for agent to reflect on failed actions and suggest alternative approaches
-class ReflectOnFailureTool extends BrowserTool {
-  constructor() {
-    super(
-      "reflect_on_failure", 
-      "Analyze why an action failed and suggest alternative approaches. Use this when verification shows an action didn't work as expected.",
-      z.object({
-        tabId: CommonToolArgs.tabId.optional().describe("Tab ID (optional - will use active tab if not specified)"),
-        failedAction: z.object({
-          type: z.string().describe("Type of action that failed (click, fill, etc.)"),
-          target: z.string().describe("Selector or description of target element"),
-          expected: z.string().describe("What was expected to happen"),
-          actual: z.string().describe("What actually happened or didn't happen")
-        }).describe("Details about the failed action"),
-        contextAnalysis: z.boolean().default(true).optional()
-          .describe("Perform deep context analysis of the target area")
-      })
-    );
-  }
-
-  async call({ tabId, failedAction, contextAnalysis = true }) {
-    try {
-      const validTabId = await getValidTabId(tabId);
-      
-      console.log(`🤔 Reflecting on failed ${failedAction.type} action: ${failedAction.target}`);
-      
-      const response = await chrome.tabs.sendMessage(validTabId, {
-        type: 'REFLECT_ON_FAILURE',
-        data: { failedAction, contextAnalysis }
-      });
-      
-      if (response && response.error) {
-        throw new Error(`Reflection failed: ${response.error}`);
-      }
-      
-      const { analysis, suggestions } = response;
-      
-      console.log(`💡 Reflection complete: ${suggestions.length} alternative approaches suggested`);
-      
-      return `🤔 REFLECTION ON FAILED ACTION:
-
-**Failed Action**: ${failedAction.type} on "${failedAction.target}"
-**Expected**: ${failedAction.expected}
-**Actual**: ${failedAction.actual}
-
-**Analysis**: ${analysis.summary}
-
-**Root Cause**: ${analysis.likelyCause}
-
-**Alternative Approaches**:
-${suggestions.map((suggestion, i) => 
-  `${i + 1}. **${suggestion.approach}**: ${suggestion.description}
-     - Method: ${suggestion.method}
-     - Success Probability: ${suggestion.probability}%`
-).join('\n\n')}
-
-**Recommended Next Action**: ${suggestions[0]?.approach || 'Try a different selector or wait for page to load'}`;
-      
-    } catch (error) {
-      console.error('[AI_AGENT] ReflectOnFailureTool error:', error);
-      throw new Error(`Reflection failed: ${error.message}`);
-    }
-  }
-}
-
-// Enhanced click tool with verification and retry logic
-class ClickElementWithRetryTool extends BrowserTool {
-  constructor() {
-    super(
-      "click_element_retry",
-      "Click an element with intelligent verification and retry logic. Automatically verifies the click worked and tries alternative approaches if it failed.",
-      z.object({
-        tabId: CommonToolArgs.tabId.optional().describe("Tab ID (optional - will use active tab if not specified)"),
-        selector: CommonToolArgs.selector,
-        expectedEffect: z.object({
-          type: z.enum(["navigation", "dropdown", "modal", "form_change", "content_change", "no_visible_change"])
-            .describe("Expected type of change after clicking"),
-          description: z.string().optional().describe("Description of expected change"),
-          verificationSelector: z.string().optional()
-            .describe("Selector to check for successful action"),
-          verificationText: z.string().optional()
-            .describe("Text that should appear/change after clicking")
-        }).optional().describe("Expected effects of the click for verification"),
-        maxRetries: z.number().min(1).max(5).default(3).optional()
-          .describe("Maximum number of retry attempts with different strategies"),
-        retryDelay: z.number().min(500).max(5000).default(1000).optional()
-          .describe("Delay between retry attempts in milliseconds")
-      })
-    );
-  }
-
-  async call({ tabId, selector, expectedEffect, maxRetries = 3, retryDelay = 1000 }) {
-    const validTabId = await getValidTabId(tabId);
-    
-    console.log(`🖱️ Clicking ${selector} with smart retry (max ${maxRetries} attempts)`);
-    
-    let lastError = null;
-    
-    // Try different click strategies
-    const strategies = [
-      { name: "standard_click", description: "Standard click with focus" },
-      { name: "scroll_and_click", description: "Scroll into view then click" },
-      { name: "coordinate_click", description: "Click at element center coordinates" },
-      { name: "javascript_click", description: "Direct JavaScript click event" },
-      { name: "force_click", description: "Force click with multiple event types" }
-    ];
-    
-    for (let attempt = 0; attempt < maxRetries; attempt++) {
-      const strategy = strategies[attempt % strategies.length];
-      
-      try {
-        console.log(`🎯 Attempt ${attempt + 1}: Using ${strategy.name} - ${strategy.description}`);
-        
-        await ensureContentScript(validTabId);
-        
-        // Capture state before clicking
-        const beforeState = await chrome.tabs.sendMessage(validTabId, {
-          type: 'CAPTURE_STATE',
-          data: { target: selector }
-        });
-        
-        // Perform click with specific strategy
-        const clickResponse = await chrome.tabs.sendMessage(validTabId, {
-          type: 'CLICK_WITH_STRATEGY',
-          data: { selector, strategy: strategy.name }
-        });
-        
-        if (clickResponse && clickResponse.error) {
-          throw new Error(clickResponse.error);
-        }
-        
-        // Wait for effects
-        await new Promise(resolve => setTimeout(resolve, retryDelay));
-        
-        // Verify the click worked
-        if (expectedEffect) {
-          const verifyResponse = await chrome.tabs.sendMessage(validTabId, {
-            type: 'VERIFY_CLICK_EFFECT',
-            data: { 
-              selector, 
-              expectedEffect, 
-              beforeState,
-              strategy: strategy.name 
-            }
-          });
-          
-          if (verifyResponse && verifyResponse.verified) {
-            console.log(`✅ Click successful with ${strategy.name}: ${verifyResponse.details}`);
-            return `✅ Successfully clicked ${selector} using ${strategy.name}. Effect: ${verifyResponse.details}`;
-          } else {
-            console.log(`⚠️ Click attempt ${attempt + 1} with ${strategy.name} - no expected effect detected`);
-            lastError = new Error(`Click had no visible effect: ${verifyResponse?.details || 'No change detected'}`);
-            
-            if (attempt < maxRetries - 1) {
-              continue; // Try next strategy
-            }
-          }
-        } else {
-          // No verification needed, assume success if no error
-          console.log(`✅ Click completed with ${strategy.name} (no verification requested)`);
-          return `✅ Clicked ${selector} using ${strategy.name}`;
-        }
-        
-      } catch (error) {
-        console.log(`❌ Attempt ${attempt + 1} failed with ${strategy.name}: ${error.message}`);
-        lastError = error;
-        
-        if (attempt < maxRetries - 1) {
-          await new Promise(resolve => setTimeout(resolve, retryDelay));
-          continue;
-        }
-      }
-    }
-    
-    // All attempts failed - provide reflection
-    console.log(`💭 All ${maxRetries} click attempts failed. Suggesting reflection.`);
-    
-    throw new Error(`❌ Click failed after ${maxRetries} attempts with different strategies. Last error: ${lastError?.message}. Use reflect_on_failure tool to analyze and find alternative approaches.`);
-  }
-}
-
-// Enhanced form fill tool with verification
-class FillFormFieldWithRetryTool extends BrowserTool {
-  constructor() {
-    super(
-      "fill_form_field_retry",
-      "Fill a form field with intelligent verification and retry logic. Automatically verifies the value was set and tries alternative approaches if it failed.",
-      z.object({
-        tabId: CommonToolArgs.tabId.optional().describe("Tab ID (optional - will use active tab if not specified)"),
-        selector: CommonToolArgs.selector,
-        value: CommonToolArgs.value,
-        verifyValue: z.boolean().default(true).optional()
-          .describe("Verify that the value was actually set in the field"),
-        maxRetries: z.number().min(1).max(5).default(3).optional()
-          .describe("Maximum number of retry attempts"),
-        retryDelay: z.number().min(200).max(3000).default(500).optional()
-          .describe("Delay between retry attempts in milliseconds")
-      })
-    );
-  }
 
-  async call({ tabId, selector, value, verifyValue = true, maxRetries = 3, retryDelay = 500 }) {
-    const validTabId = await getValidTabId(tabId);
-    
-    console.log(`📝 Filling ${selector} with "${value}" (smart retry enabled)`);
-    
-    const strategies = [
-      { name: "standard_fill", description: "Standard focus, clear, and type" },
-      { name: "triple_click_fill", description: "Triple-click to select all, then type" },
-      { name: "key_by_key", description: "Clear with backspace, then type character by character" },
-      { name: "javascript_set", description: "Direct JavaScript value assignment" },
-      { name: "clipboard_paste", description: "Simulate clipboard paste operation" }
-    ];
-    
-    let lastError = null;
-    
-    for (let attempt = 0; attempt < maxRetries; attempt++) {
-      const strategy = strategies[attempt % strategies.length];
-      
-      try {
-        console.log(`📝 Attempt ${attempt + 1}: Using ${strategy.name} - ${strategy.description}`);
-        
-        await ensureContentScript(validTabId);
-        
-        // Fill using specific strategy
-        const fillResponse = await chrome.tabs.sendMessage(validTabId, {
-          type: 'FILL_WITH_STRATEGY',
-          data: { selector, value, strategy: strategy.name }
-        });
-        
-        if (fillResponse && fillResponse.error) {
-          throw new Error(fillResponse.error);
-        }
-        
-        // Wait for value to be set
-        await new Promise(resolve => setTimeout(resolve, retryDelay));
-        
-        // Verify the value was set
-        if (verifyValue) {
-          const verifyResponse = await chrome.tabs.sendMessage(validTabId, {
-            type: 'VERIFY_FIELD_VALUE',
-            data: { selector, expectedValue: value }
-          });
-          
-          if (verifyResponse && verifyResponse.verified) {
-            console.log(`✅ Form fill successful with ${strategy.name}: value verified`);
-            return `✅ Successfully filled ${selector} with "${value}" using ${strategy.name}. Value verified in field.`;
-          } else {
-            console.log(`⚠️ Fill attempt ${attempt + 1} - value not verified in field`);
-            lastError = new Error(`Value not set correctly: expected "${value}", got "${verifyResponse?.actualValue || 'undefined'}"`);
-            
-            if (attempt < maxRetries - 1) {
-              continue;
-            }
-          }
-        } else {
-          console.log(`✅ Form fill completed with ${strategy.name} (no verification requested)`);
-          return `✅ Filled ${selector} with "${value}" using ${strategy.name}`;
-        }
-        
-      } catch (error) {
-        console.log(`❌ Fill attempt ${attempt + 1} failed with ${strategy.name}: ${error.message}`);
-        lastError = error;
-        
-        if (attempt < maxRetries - 1) {
-          await new Promise(resolve => setTimeout(resolve, retryDelay));
-          continue;
-        }
-      }
-    }
-    
-    throw new Error(`❌ Form fill failed after ${maxRetries} attempts. Last error: ${lastError?.message}. Use reflect_on_failure tool to analyze the form field and find alternative approaches.`);
-  }
-}
 
 // AI Planning and Reasoning Tools
 
@@ -2185,20 +1852,15 @@ ${Object.entries(patterns.toolSuccessRates).map(([tool, rate]) => `- ${tool}: ${
 }
 
 export const browserTools = [
-  // Core agent control tools
-  new ReasoningTool(),
+  // ReAct Pattern Tools (3-step cycle)
+  new ThoughtTool(),      // Step 1: Think before acting
+  new ObservationTool(),  // Step 3: Analyze results after actions
   
   // Tab management
   new GetActiveTabTool(),
   new CreateNewTabTool(),
   new NavigateToURLTool(),
   
-  // Simplified command tools (industry best practices)
-  // new ClickTool(),
-  // new TypeTool(),
-  // new FillTool(),
-  // new GetPageTool(),
-  // new FindElementTool(),
   
   // Legacy tools for backward compatibility
   new ClickElementTool(),
@@ -2222,9 +1884,6 @@ export const browserTools = [
   
   // Verification and intelligence tools
   new VerifyActionTool(),
-  // Replaced ReflectOnFailureTool with AskUserQuestionTool for interactive user input
-  // new ClickElementWithRetryTool(),
-  // new FillFormFieldWithRetryTool()
   
   // AI Planning and Reasoning Tools
   new CreatePlanTool(),
diff --git a/chrome/browser/resources/vibe/apps/chat4/src/components/chat/ChatPage.tsx b/chrome/browser/resources/vibe/apps/chat4/src/components/chat/ChatPage.tsx
index 9a534ede0b..d6b5d91dd1 100644
--- a/chrome/browser/resources/vibe/apps/chat4/src/components/chat/ChatPage.tsx
+++ b/chrome/browser/resources/vibe/apps/chat4/src/components/chat/ChatPage.tsx
@@ -5,7 +5,7 @@ import { Sidebar } from "./Sidebar"
 import { MessageList } from "./MessageList"
 import { ChatInput } from "./ChatInput"
 import { type MessageData } from "./Message"
-import { aiAgent, type AIToolUpdate, type AIReasoningUpdate } from "../../utils/aiAgent"
+import { aiAgent, type AIToolUpdate, type AIReasoningUpdate, type AIReActUpdate } from "../../utils/aiAgent"
 
 interface ChatSession {
   id: string
@@ -115,7 +115,7 @@ export function ChatPage() {
   // Setup AI agent handlers
   useEffect(() => {
     aiAgent.setToolUpdateHandler((update: AIToolUpdate) => {
-      console.log('🔧 [CHAT4] Tool update received:', update)
+      console.log('🔧 [CHAT4] Tool update received:', JSON.stringify(update, null, 2))
       
       // Check if this is AskUserQuestion tool being called
       if (update.tool === 'ask_user_question' || update.tool === 'AskUserQuestionTool') {
@@ -151,7 +151,7 @@ export function ChatPage() {
     })
     
     aiAgent.setReasoningUpdateHandler((update: AIReasoningUpdate) => {
-      console.log('🧠 [CHAT4] Reasoning update received:', update)
+      console.log('🧠 [CHAT4] Reasoning update received:', JSON.stringify(update, null, 2))
       
       // Start thinking indicator if not already started
       if (!isProcessing) {
@@ -194,6 +194,40 @@ export function ChatPage() {
         ))
       }
     })
+
+    aiAgent.setReActUpdateHandler((update: AIReActUpdate) => {
+      console.log(`🔄 [CHAT4] ReAct ${update.stepType} update received:`, JSON.stringify(update, null, 2))
+      
+      // Start thinking indicator if not already started
+      if (!isProcessing) {
+        setIsProcessing(true)
+        setThinkingStartTime(Date.now())
+        setProcessingDuration(0)
+      }
+      
+      // Create ReAct step message
+      const reactStepMessage: MessageData = {
+        id: generateId(),
+        content: `${update.stepType.charAt(0).toUpperCase() + update.stepType.slice(1)} - Iteration ${update.data.iteration}`,
+        role: "assistant",
+        timestamp: new Date(update.timestamp),
+        type: "react_step",
+        reactStep: {
+          stepType: update.stepType,
+          data: update.data
+        }
+      }
+      
+      setSessions(prev => prev.map(session => 
+        session.id === currentSessionId
+          ? { 
+              ...session, 
+              messages: [...session.messages, reactStepMessage],
+              timestamp: new Date()
+            }
+          : session
+      ))
+    })
     
     return () => {
       aiAgent.cleanup()
@@ -438,7 +472,7 @@ export function ChatPage() {
     setProcessingDuration(0)
 
     try {
-      console.log('🚀 [CHAT4] Sending message to AI agent:', userMessageContent)
+      console.log('🚀 [CHAT4] Sending message to AI agent:', JSON.stringify(userMessageContent, null, 2))
       
       // Send message to AI agent via Chrome extension messaging
       const response = await aiAgent.sendMessage(userMessageContent)
diff --git a/chrome/browser/resources/vibe/apps/chat4/src/components/chat/Message.tsx b/chrome/browser/resources/vibe/apps/chat4/src/components/chat/Message.tsx
index 561eb0d354..753aa8f0cb 100644
--- a/chrome/browser/resources/vibe/apps/chat4/src/components/chat/Message.tsx
+++ b/chrome/browser/resources/vibe/apps/chat4/src/components/chat/Message.tsx
@@ -4,12 +4,28 @@ import React, { useState } from "react"
 import { Avatar, AvatarFallback } from "@/components/ui/avatar"
 import { Button } from "@/components/ui/button"
 import { Copy, Check } from "lucide-react"
+import { ReActStep } from "./ReActStep"
 
 export interface MessageData {
   id: string
   content: string
   role: "user" | "assistant"
   timestamp: Date
+  type?: "message" | "react_step"
+  reactStep?: {
+    stepType: 'thought' | 'action' | 'observation'
+    data: {
+      iteration: number
+      reasoning?: string
+      plan?: string
+      confidence?: number
+      tool?: string
+      input?: unknown
+      result?: string
+      analysis?: string
+      next_goal?: string
+    }
+  }
 }
 
 interface MessageProps {
@@ -63,6 +79,19 @@ export function Message({ message }: MessageProps) {
       console.error('Failed to copy text:', err)
     }
   }
+
+  // Handle ReAct step messages
+  if (message.type === "react_step" && message.reactStep) {
+    return (
+      <div className="px-4 py-2">
+        <ReActStep
+          stepType={message.reactStep.stepType}
+          data={message.reactStep.data}
+          timestamp={message.timestamp}
+        />
+      </div>
+    )
+  }
   
   return (
     <div className={`group flex gap-3 px-4 py-6 bg-black/5 dark:bg-white/5 hover:bg-gray-50/50 dark:hover:bg-gray-800/30 ${isAssistant ? "" : "flex-row-reverse"}`}>
diff --git a/chrome/browser/resources/vibe/apps/chat4/src/components/chat/ReActStep.tsx b/chrome/browser/resources/vibe/apps/chat4/src/components/chat/ReActStep.tsx
new file mode 100644
index 0000000000..667a67abe7
--- /dev/null
+++ b/chrome/browser/resources/vibe/apps/chat4/src/components/chat/ReActStep.tsx
@@ -0,0 +1,146 @@
+"use client"
+
+import React from "react"
+import { Brain, Zap, Eye } from "lucide-react"
+
+export interface ReActStepData {
+  iteration: number;
+  reasoning?: string;
+  plan?: string;
+  confidence?: number;
+  tool?: string;
+  input?: unknown;
+  result?: string;
+  analysis?: string;
+  next_goal?: string;
+}
+
+interface ReActStepProps {
+  stepType: 'thought' | 'action' | 'observation';
+  data: ReActStepData;
+  timestamp: Date;
+}
+
+const stepIcons = {
+  thought: Brain,
+  action: Zap,
+  observation: Eye
+};
+
+const stepColors = {
+  thought: 'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800',
+  action: 'bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800',
+  observation: 'bg-orange-50 dark:bg-orange-900/20 border-orange-200 dark:border-orange-800'
+};
+
+const stepTitles = {
+  thought: 'Thought',
+  action: 'Action',
+  observation: 'Observation'
+};
+
+const stepTextColors = {
+  thought: 'text-blue-700 dark:text-blue-300',
+  action: 'text-green-700 dark:text-green-300',
+  observation: 'text-orange-700 dark:text-orange-300'
+};
+
+export function ReActStep({ stepType, data, timestamp }: ReActStepProps) {
+  const Icon = stepIcons[stepType];
+  
+  const renderStepContent = () => {
+    switch (stepType) {
+      case 'thought':
+        return (
+          <div className="space-y-2">
+            {data.reasoning && (
+              <div>
+                <span className="font-medium text-sm">Reasoning:</span>
+                <p className="text-sm mt-1">{data.reasoning}</p>
+              </div>
+            )}
+            {data.plan && (
+              <div>
+                <span className="font-medium text-sm">Plan:</span>
+                <p className="text-sm mt-1">{data.plan}</p>
+              </div>
+            )}
+            {data.confidence !== undefined && (
+              <div>
+                <span className="font-medium text-sm">Confidence:</span>
+                <span className="text-sm ml-2">{Math.round(data.confidence * 100)}%</span>
+              </div>
+            )}
+          </div>
+        );
+        
+      case 'action':
+        return (
+          <div className="space-y-2">
+            {data.tool && (
+              <div>
+                <span className="font-medium text-sm">Tool:</span>
+                <span className="text-sm ml-2 font-mono bg-gray-100 dark:bg-gray-800 px-1.5 py-0.5 rounded">
+                  {data.tool}
+                </span>
+              </div>
+            )}
+            {data.input && (
+              <div>
+                <span className="font-medium text-sm">Input:</span>
+                <pre className="text-xs mt-1 bg-gray-100 dark:bg-gray-800 p-2 rounded overflow-x-auto">
+                  {typeof data.input === 'object' ? JSON.stringify(data.input, null, 2) : String(data.input)}
+                </pre>
+              </div>
+            )}
+          </div>
+        );
+        
+      case 'observation':
+        return (
+          <div className="space-y-2">
+            {data.result && (
+              <div>
+                <span className="font-medium text-sm">Result:</span>
+                <p className="text-sm mt-1">{data.result}</p>
+              </div>
+            )}
+            {data.analysis && (
+              <div>
+                <span className="font-medium text-sm">Analysis:</span>
+                <p className="text-sm mt-1">{data.analysis}</p>
+              </div>
+            )}
+            {data.next_goal && (
+              <div>
+                <span className="font-medium text-sm">Next Goal:</span>
+                <p className="text-sm mt-1">{data.next_goal}</p>
+              </div>
+            )}
+          </div>
+        );
+        
+      default:
+        return null;
+    }
+  };
+
+  return (
+    <div className={`border rounded-lg p-3 mb-2 ${stepColors[stepType]}`}>
+      <div className="flex items-center gap-2 mb-2">
+        <Icon className={`h-4 w-4 ${stepTextColors[stepType]}`} />
+        <span className={`font-medium text-sm ${stepTextColors[stepType]}`}>
+          {stepTitles[stepType]} (Iteration {data.iteration})
+        </span>
+        <span className="text-xs text-gray-500 ml-auto">
+          {timestamp.toLocaleTimeString([], { 
+            hour: '2-digit', 
+            minute: '2-digit',
+            second: '2-digit'
+          })}
+        </span>
+      </div>
+      {renderStepContent()}
+    </div>
+  );
+}
\ No newline at end of file
diff --git a/chrome/browser/resources/vibe/apps/chat4/src/utils/aiAgent.ts b/chrome/browser/resources/vibe/apps/chat4/src/utils/aiAgent.ts
index 8d4a6b45c6..f9432ee8a0 100644
--- a/chrome/browser/resources/vibe/apps/chat4/src/utils/aiAgent.ts
+++ b/chrome/browser/resources/vibe/apps/chat4/src/utils/aiAgent.ts
@@ -57,6 +57,22 @@ export interface AIReasoningUpdate {
   timestamp: number;
 }
 
+export interface AIReActUpdate {
+  stepType: 'thought' | 'action' | 'observation';
+  data: {
+    iteration: number;
+    reasoning?: string;
+    plan?: string;
+    confidence?: number;
+    tool?: string;
+    input?: unknown;
+    result?: string;
+    analysis?: string;
+    next_goal?: string;
+  };
+  timestamp: number;
+}
+
 export interface AIResponse {
   success: boolean;
   response?: string;
@@ -69,6 +85,7 @@ export class Chat4AIAgent {
   private currentOperationId: string | null = null;
   private onToolUpdate?: (update: AIToolUpdate) => void;
   private onReasoningUpdate?: (update: AIReasoningUpdate) => void;
+  private onReActUpdate?: (update: AIReActUpdate) => void;
   private messageListener?: (message: ChromeMessage, sender: MessageSender, sendResponse: (response?: unknown) => void) => void;
 
   constructor() {
@@ -94,6 +111,14 @@ export class Chat4AIAgent {
             timestamp: message.timestamp as number
           });
         }
+      } else if (message.type === 'REACT_UPDATE') {
+        if (this.onReActUpdate) {
+          this.onReActUpdate({
+            stepType: message.stepType as 'thought' | 'action' | 'observation',
+            data: message.data as AIReActUpdate['data'],
+            timestamp: message.timestamp as number
+          });
+        }
       }
     };
 
@@ -129,6 +154,15 @@ export class Chat4AIAgent {
             timestamp: Date.now()
           });
         }
+      } else if (message.type === 'REACT_UPDATE') {
+        console.log('🔄 [CHAT4] Received ReAct update from content script:', JSON.stringify(message, null, 2));
+        if (this.onReActUpdate) {
+          this.onReActUpdate({
+            stepType: message.stepType,
+            data: message.data,
+            timestamp: Date.now()
+          });
+        }
       }
     };
 
@@ -143,6 +177,10 @@ export class Chat4AIAgent {
     this.onReasoningUpdate = handler;
   }
 
+  public setReActUpdateHandler(handler: (update: AIReActUpdate) => void) {
+    this.onReActUpdate = handler;
+  }
+
   public async sendMessage(content: string): Promise<AIResponse> {
     return new Promise((resolve, reject) => {
       if (!chromeExt?.runtime) {
diff --git a/chrome/browser/resources/vibe/background.js b/chrome/browser/resources/vibe/background.js
index 84fa1ad5e8..d6b105f1cf 100644
--- a/chrome/browser/resources/vibe/background.js
+++ b/chrome/browser/resources/vibe/background.js
@@ -539,6 +539,11 @@ chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
       handleReasoningUpdate(message, sendResponse);
       return true; // Keep the message channel open for async response
       
+    case 'REACT_UPDATE':
+      // Forward ReAct step updates to Chat4
+      handleReActUpdate(message, sendResponse);
+      return true; // Keep the message channel open for async response
+      
     case 'AI_AGENT_REQUEST':
       // Handle AI agent requests from home page
       handleAIAgentRequest(message, sendResponse);
@@ -582,6 +587,25 @@ async function handleToolUpdate(message, sendResponse) {
 }
 
 // Handle reasoning updates from AI agent
+async function handleReActUpdate(message, sendResponse) {
+  console.log(`🔄 [REACT-UPDATE] ${message.stepType.toUpperCase()} step received for iteration:`, message.data.iteration);
+  
+  try {
+    // Forward to Chat4 UI
+    await chrome.runtime.sendMessage({
+      type: 'REACT_UPDATE',
+      stepType: message.stepType,
+      data: message.data,
+      timestamp: message.timestamp
+    });
+    
+    sendResponse({ success: true });
+  } catch (error) {
+    console.error('❌ [REACT-UPDATE] Failed to forward ReAct update:', error);
+    sendResponse({ success: false, error: error.message });
+  }
+}
+
 async function handleReasoningUpdate(message, sendResponse) {
   console.log('🧠 [REASONING-UPDATE] Reasoning update received for iteration:', message.iteration);
   
@@ -663,7 +687,7 @@ async function handleSidePanelCommand(message, sendResponse) {
       operationId: operationId
     });
     
-    console.log('✅ [SIDE-PANEL] Command processed successfully:', result);
+    console.log('✅ [SIDE-PANEL] Command processed successfully:', JSON.stringify(result, null, 2));
     
     // Clean up operation tracking
     if (operationId) {
diff --git a/chrome/browser/resources/vibe/content.js b/chrome/browser/resources/vibe/content.js
index beab368de4..3e0cc7f149 100644
--- a/chrome/browser/resources/vibe/content.js
+++ b/chrome/browser/resources/vibe/content.js
@@ -326,7 +326,6 @@ chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
 
       case "TOOL_UPDATE":
         // Forward tool update messages to Chat4 UI
-        console.log("🔧 [CONTENT] Forwarding tool update to Chat4:", message);
         window.postMessage({
           type: "TOOL_UPDATE",
           operationId: message.operationId,
@@ -339,7 +338,6 @@ chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
 
       case "REASONING_UPDATE":
         // Forward reasoning update messages to Chat4 UI
-        console.log("🧠 [CONTENT] Forwarding reasoning update to Chat4:", message);
         window.postMessage({
           type: "REASONING_UPDATE",
           operationId: message.operationId,
diff --git a/chrome/browser/resources/vibe/test_agent_logging.js b/chrome/browser/resources/vibe/test_agent_logging.js
new file mode 100644
index 0000000000..3bd9148284
--- /dev/null
+++ b/chrome/browser/resources/vibe/test_agent_logging.js
@@ -0,0 +1,35 @@
+// Test script to trigger agent and see logging output
+import { VibeLangchainAgent } from './ai_agent.js';
+
+async function testAgentWithLogging() {
+  console.log('🧪 Testing agent with comprehensive logging...');
+  
+  const agent = new VibeLangchainAgent();
+  
+  // Use real API key from environment
+  const config = {
+    provider: 'openai',
+    model: 'gpt-4o-mini',
+    apiKey: process.env.OPENAI_API_KEY || '[REMOVED_OPENAI_KEY]',
+    temperature: 0.1
+  };
+  
+  console.log('🔧 Using config:', { provider: config.provider, model: config.model, hasApiKey: !!config.apiKey });
+  
+  try {
+    // This should trigger the reasoning tool first, then potentially get stuck
+    const result = await agent.processUserRequest({
+      user_request: "Use the reasoning tool to plan how to find flights from NYC to London, then actually search for them",
+      tabId: "test-tab-123",
+      config: config
+    });
+    
+    console.log('✅ Agent completed without getting stuck:', result);
+  } catch (error) {
+    console.error('❌ Agent failed:', error.message);
+    console.error('Stack:', error.stack);
+  }
+}
+
+// Run the test
+testAgentWithLogging().catch(console.error);
\ No newline at end of file
diff --git a/chrome/browser/resources/vibe/test_reasoning_flow.js b/chrome/browser/resources/vibe/test_reasoning_flow.js
new file mode 100644
index 0000000000..f2ed08d226
--- /dev/null
+++ b/chrome/browser/resources/vibe/test_reasoning_flow.js
@@ -0,0 +1,46 @@
+// Test script to examine reasoning tool flow
+import { VibeLangchainAgent } from './ai_agent.js';
+
+// Mock a simple test to see the tool flow
+async function testReasoningFlow() {
+  console.log('🧪 Testing reasoning tool flow...');
+  
+  const agent = new VibeLangchainAgent();
+  
+  // Mock config with API key
+  const config = {
+    provider: 'openai',
+    model: 'gpt-4o-mini',
+    apiKey: 'mock-key-for-testing',
+    temperature: 0.1
+  };
+  
+  try {
+    // This will fail due to mock API key, but we can see the flow
+    const result = await agent.processUserRequest({
+      user_request: "use reasoning tool to think about finding flights",
+      tabId: "test-tab",
+      config: config
+    });
+    
+    console.log('Result:', result);
+  } catch (error) {
+    console.log('Expected error (mock API key):', error.message);
+    
+    // Let's examine what tools are available
+    console.log('\n📋 Available tools:');
+    agent.tools.forEach(tool => {
+      console.log(`- ${tool.name}: ${tool.description}`);
+    });
+    
+    // Check if reasoning tool exists
+    const reasoningTool = agent.tools.find(t => t.name === 'reasoning');
+    if (reasoningTool) {
+      console.log('\n🧠 Reasoning tool found!');
+      console.log('Schema:', reasoningTool.schema);
+    }
+  }
+}
+
+// Run the test
+testReasoningFlow().catch(console.error);
\ No newline at end of file
diff --git a/chrome/browser/resources/vibe/trigger_reasoning_test.html b/chrome/browser/resources/vibe/trigger_reasoning_test.html
new file mode 100644
index 0000000000..7ad7779347
--- /dev/null
+++ b/chrome/browser/resources/vibe/trigger_reasoning_test.html
@@ -0,0 +1,25 @@
+<!DOCTYPE html>
+<html>
+<head>
+    <title>Reasoning Tool Test</title>
+</head>
+<body>
+    <h1>Test Reasoning Tool Flow</h1>
+    <p>This page will trigger the agent to use reasoning tool first, then potentially get stuck.</p>
+    
+    <script>
+        // Simulate triggering the agent via omnibox
+        console.log('🧪 Test page loaded - ready to test agent');
+        
+        // Log when agent gets triggered
+        if (typeof chrome !== 'undefined' && chrome.runtime) {
+            chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
+                console.log('📨 Received message:', JSON.stringify(message, null, 2));
+                if (message.type === 'REASONING_UPDATE') {
+                    console.log('🧠 REASONING UPDATE:', JSON.stringify(message, null, 2));
+                }
+            });
+        }
+    </script>
+</body>
+</html>
\ No newline at end of file
-- 
2.50.0

