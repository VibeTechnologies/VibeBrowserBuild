From adcf2036a86a7c421ad33ce8b9583e14898eb419 Mon Sep 17 00:00:00 2001
From: Den <2119348+dzianisv@users.noreply.github.com>
Date: Sat, 26 Jul 2025 01:21:05 +0300
Subject: [PATCH 033/107] improve tooling

---
 .../resources/vibe/ai_tools.extension.js      | 345 ++++++++++--------
 chrome/browser/resources/vibe/background.js   | 142 ++++++-
 chrome/browser/resources/vibe/content.js      | 280 +++++++++++---
 3 files changed, 537 insertions(+), 230 deletions(-)

diff --git a/chrome/browser/resources/vibe/ai_tools.extension.js b/chrome/browser/resources/vibe/ai_tools.extension.js
index 13d13fcff3..aa57a4758b 100644
--- a/chrome/browser/resources/vibe/ai_tools.extension.js
+++ b/chrome/browser/resources/vibe/ai_tools.extension.js
@@ -18,6 +18,22 @@ const ALLOWED_HOSTNAMES = [
   'youtube.com', 'linkedin.com', 'twitter.com', 'facebook.com'
 ];
 
+// Utility function to check if an error is recoverable
+function isRecoverableError(errorMessage) {
+  const recoverableErrors = [
+    'comboboxSelectors is not defined',
+    'Element not found',
+    'Could not find element',
+    'No input appeared',
+    'ReferenceError',
+    'TypeError: Cannot read'
+  ];
+  
+  return recoverableErrors.some(error => 
+    errorMessage.toLowerCase().includes(error.toLowerCase())
+  );
+}
+
 // Utility function to validate URL security
 function validateUrlSecurity(url) {
   try {
@@ -538,6 +554,54 @@ class NavigateToURLTool extends BrowserTool {
   }
 }
 
+// Simplified fill command following industry patterns
+class FillTool extends BrowserTool {
+  constructor() {
+    super(
+      "fill",
+      "Fill a form field using role-based locators or CSS selectors. Automatically handles different input types.",
+      z.object({
+        tabId: CommonToolArgs.tabId.optional(),
+        target: z.union([
+          z.string().describe("CSS selector or role-based locator (e.g., 'role:textbox[name=Email]', 'placeholder:Enter email')"),
+          z.object({
+            role: z.string().optional(),
+            name: z.string().optional(),
+            placeholder: z.string().optional(),
+            selector: z.string().optional()
+          }).describe("Locator object")
+        ]).describe("Target element to fill"),
+        value: z.string().describe("Value to fill")
+      })
+    );
+  }
+  
+  async call({ tabId, target, value }) {
+    try {
+      const validTabId = await getValidTabId(tabId);
+      
+      await ensureContentScript(validTabId);
+      
+      const command = {
+        type: 'FILL',
+        data: { target, value }
+      };
+      
+      const response = await chrome.tabs.sendMessage(validTabId, command);
+      
+      if (response && response.error) {
+        throw new Error(`Fill failed: ${response.error}`);
+      }
+      
+      return `Filled ${typeof target === 'string' ? target : JSON.stringify(target)} with "${value}"`;
+    } catch (error) {
+      console.error('[AI_AGENT] FillTool error:', error);
+      throw new Error(`Fill failed: ${error.message}`);
+    }
+  }
+}
+
+// Legacy FillFormFieldTool for backward compatibility
 class FillFormFieldTool extends BrowserTool {
   constructor() {
     super(
@@ -552,32 +616,23 @@ class FillFormFieldTool extends BrowserTool {
   }
   async call({ tabId, selector, value }) {
     try {
-      // Use robust tab validation with fallback
       const validTabId = await getValidTabId(tabId);
       
-      console.log(`üìù Filling form field on tab ${validTabId}: ${selector} = "${value}"`);
-      
-      // Ensure content script is loaded
       await ensureContentScript(validTabId);
       
-      // Send fill form message
       const response = await chrome.tabs.sendMessage(validTabId, { 
         type: "fillForm", 
         data: { selector, value } 
       });
       
       if (response && response.error) {
-        throw new Error(`Content script error: ${response.error}`);
+        throw new Error(`Fill form failed: ${response.error}`);
       }
       
-      console.log(`‚úÖ Successfully filled field ${selector} on tab ${validTabId}`);
-      return `Filled field ${selector} with "${value}" on tab ${validTabId}`;
+      return `Filled field ${selector} with "${value}"`;
     } catch (error) {
-      console.error('‚ùå FillFormFieldTool error:', error);
-      const errorMsg = error.message.includes('Could not establish connection') 
-        ? 'Content script not available - page may need to be refreshed'
-        : error.message;
-      throw new Error(`Fill form failed: ${errorMsg}`);
+      console.error('[AI_AGENT] FillFormFieldTool error:', error);
+      throw new Error(`Fill form failed: ${error.message}`);
     }
   }
 }
@@ -775,71 +830,43 @@ class AskUserQuestionTool extends BrowserTool {
   }
 }
 
-// Enhanced page content tool with intelligent interactive element highlighting
-class GetPageContentTool extends BrowserTool {
+// Simplified page analysis tool using DOM locators
+class GetPageTool extends BrowserTool {
   constructor() {
     super(
-      "get_page_content",
-      "Get enhanced page content with intelligent highlighting of interactive elements and changes. This helps the agent SEE and UNDERSTAND dynamic content like dropdowns.",
+      "get_page",
+      "Get page content with role-based element detection. Uses modern DOM locators for better element identification.",
       z.object({
         tabId: CommonToolArgs.tabId.optional().describe("Tab ID (optional - will use active tab if not specified)"),
-        includeInteractive: z.boolean().default(true).describe("Highlight clickable and interactive elements with [CLICKABLE] markers"),
-        includeAriaInfo: z.boolean().default(true).describe("Include ARIA labels and roles for accessibility context"),
-        includeChanges: z.boolean().default(false).describe("Show what changed since last call - IMPORTANT for seeing new dropdowns"),
-        focusArea: z.string().optional().describe("CSS selector to focus on specific area (e.g., 'form', '.dropdown-container')"),
-        diff: z.boolean().default(false).optional().describe("Legacy parameter - use includeChanges instead")
+        mode: z.enum(["text", "interactive", "forms", "all"]).default("all").describe("What to extract from the page"),
+        locators: z.array(z.string()).optional().describe("Specific role-based locators to find (e.g., 'role:button', 'role:textbox', 'label:Email')"),
+        area: z.string().optional().describe("CSS selector to focus on specific area")
       })
     );
   }
 
-  async call({ tabId, includeInteractive = true, includeAriaInfo = true, includeChanges = false, focusArea, diff = false }) {
+  async call({ tabId, mode = "all", locators, area }) {
     try {
-      // Use robust tab validation with fallback
       const validTabId = await getValidTabId(tabId);
       
-      // Get tab info for logging
-      const tabInfo = await chrome.tabs.get(validTabId);
-      
-      // Support legacy diff parameter
-      const showChanges = includeChanges || diff;
-      const logType = showChanges ? 'intelligent content with changes' : 'intelligent page content';
-      console.log(`üß† Getting ${logType} from tab ${validTabId} (${tabInfo.url || 'unknown URL'})`);
-      
-      // Ensure content script is loaded
       await ensureContentScript(validTabId);
       
-      // Send enhanced message to content script
-      const messageType = showChanges ? 'GET_PAGE_CONTENT_DIFF' : 'GET_PAGE_CONTENT';
-      const response = await chrome.tabs.sendMessage(validTabId, {
-        type: messageType,
-        data: {
-          includeInteractive,
-          includeAriaInfo,
-          includeChanges: showChanges,
-          focusArea
-        }
-      });
-      
-      if (!response) {
-        throw new Error('No response from content script');
-      }
+      // Modern approach using role-based queries
+      const command = {
+        type: 'GET_PAGE',
+        data: { mode, locators, area }
+      };
       
-      if (response.error) {
-        throw new Error(`Content script error: ${response.error}`);
-      }
+      const response = await chrome.tabs.sendMessage(validTabId, command);
       
-      // Return appropriate response format
-      if (diff) {
-        // For diff requests, return the mutations array
-        return response.diff || [];
-      } else {
-        // For full content requests, return the content
-        return response.content || response;
+      if (response && response.error) {
+        throw new Error(`Get page failed: ${response.error}`);
       }
       
+      return response.content || response;
     } catch (error) {
-      console.error('[AI_AGENT] GetPageContentTool error:', error);
-      throw new Error(`Get page content failed: ${error.message}`);
+      console.error('[AI_AGENT] GetPageTool error:', error);
+      throw new Error(`Get page failed: ${error.message}`);
     }
   }
 }
@@ -1000,156 +1027,147 @@ class TakeScreenshotTool extends BrowserTool {
   }
 }
 
-// ... rest of the code remains the same ...
-class ClickAtCoordinatesTool extends BrowserTool {
+// Simple command tools inspired by industry best practices (OpenAI, Anthropic)
+class ClickTool extends BrowserTool {
   constructor() {
     super(
-      "click_at_coordinates",
-      "Click at specific pixel coordinates on the page. Use this when you have a screenshot and need to click at a specific location.",
+      "click",
+      "Click an element using selector, text, role, or coordinates. Simplified command structure following industry best practices.",
       z.object({
         tabId: CommonToolArgs.tabId.optional().describe("Tab ID (optional - will use active tab if not specified)"),
-        x: z.number().describe("X coordinate (pixels from left edge)"),
-        y: z.number().describe("Y coordinate (pixels from top edge)"),
+        target: z.union([
+          z.string().describe("CSS selector, text content, or role-based locator (e.g., 'button:Submit', 'text:Sign in', 'role:button[name=Submit]')"),
+          z.object({ 
+            x: z.number().describe("X coordinate"),
+            y: z.number().describe("Y coordinate") 
+          }).describe("Pixel coordinates")
+        ]).describe("Click target - either selector/locator or coordinates"),
         button: z.enum(["left", "right", "middle"]).default("left").optional().describe("Mouse button to click")
       })
     );
   }
 
-  async call({ tabId, x, y, button = "left" }) {
+  async call({ tabId, target, button = "left" }) {
     try {
-      // Use provided tabId or get active tab
       const targetTab = tabId ? { id: tabId } : await getCurrentActiveTab();
       const targetTabId = targetTab.id;
       
-      console.log(`üñ±Ô∏è Clicking at coordinates (${x}, ${y}) on tab ${targetTabId}`);
-      
-      // Ensure content script is loaded
       await ensureContentScript(targetTabId);
       
-      // Send click message to content script
-      const response = await chrome.tabs.sendMessage(targetTabId, {
-        type: 'CLICK_AT_COORDINATES',
-        data: { x, y, button }
-      });
+      // Simple command structure inspired by OpenAI's approach
+      const command = {
+        type: 'CLICK',
+        data: { target, button }
+      };
+      
+      const response = await chrome.tabs.sendMessage(targetTabId, command);
       
       if (response && response.error) {
-        throw new Error(`Content script error: ${response.error}`);
+        throw new Error(`Click failed: ${response.error}`);
       }
       
-      console.log(`‚úÖ Successfully clicked at coordinates (${x}, ${y})`);
-      return `Clicked at coordinates (${x}, ${y}) with ${button} mouse button`;
+      const targetDesc = typeof target === 'string' ? target : `(${target.x}, ${target.y})`;
+      return `Clicked ${targetDesc}`;
     } catch (error) {
-      console.error('[AI_AGENT] ClickAtCoordinatesTool error:', error);
-      throw new Error(`Click at coordinates failed: ${error.message}`);
+      console.error('[AI_AGENT] ClickTool error:', error);
+      throw new Error(`Click failed: ${error.message}`);
     }
   }
 }
 
-// Tool to type text at specific pixel coordinates on the page
-class TypeAtCoordinatesTool extends BrowserTool {
+// Simple type command inspired by industry best practices
+class TypeTool extends BrowserTool {
   constructor() {
     super(
-      "type_at_coordinates", 
-      "Type text at specific pixel coordinates. Use this when you have a screenshot and need to type in a field at a specific location.",
+      "type", 
+      "Type text into the currently focused element or at a specific target. Simplified command structure.",
       z.object({
         tabId: CommonToolArgs.tabId.optional().describe("Tab ID (optional - will use active tab if not specified)"),
-        x: z.number().describe("X coordinate (pixels from left edge)"),
-        y: z.number().describe("Y coordinate (pixels from top edge)"),
         text: z.string().describe("Text to type"),
+        target: z.union([
+          z.string().describe("CSS selector or role-based locator for the input field"),
+          z.object({ 
+            x: z.number().describe("X coordinate"),
+            y: z.number().describe("Y coordinate") 
+          }).describe("Pixel coordinates")
+        ]).optional().describe("Optional target - if not provided, types into currently focused element"),
         clearFirst: z.boolean().default(false).optional().describe("Clear existing content before typing")
       })
     );
   }
 
-  async call({ tabId, x, y, text, clearFirst = false }) {
+  async call({ tabId, text, target, clearFirst = false }) {
     try {
-      // Use provided tabId or get active tab
       const targetTab = tabId ? { id: tabId } : await getCurrentActiveTab();
       const targetTabId = targetTab.id;
       
-      console.log(`‚å®Ô∏è Typing "${text}" at coordinates (${x}, ${y}) on tab ${targetTabId}`);
-      
-      // Ensure content script is loaded
       await ensureContentScript(targetTabId);
       
-      // Send type message to content script
-      const response = await chrome.tabs.sendMessage(targetTabId, {
-        type: 'TYPE_AT_COORDINATES',
-        data: { x, y, text, clearFirst }
-      });
+      // Simple command structure
+      const command = {
+        type: 'TYPE',
+        data: { text, target, clearFirst }
+      };
+      
+      const response = await chrome.tabs.sendMessage(targetTabId, command);
       
       if (response && response.error) {
-        throw new Error(`Content script error: ${response.error}`);
+        throw new Error(`Type failed: ${response.error}`);
       }
       
-      console.log(`‚úÖ Successfully typed at coordinates (${x}, ${y})`);
-      return `Typed "${text}" at coordinates (${x}, ${y})${clearFirst ? ' (cleared first)' : ''}`;
+      return `Typed "${text}"${target ? ` into ${typeof target === 'string' ? target : `(${target.x}, ${target.y})`}` : ''}`;
     } catch (error) {
-      console.error('[AI_AGENT] TypeAtCoordinatesTool error:', error);
-      throw new Error(`Type at coordinates failed: ${error.message}`);
+      console.error('[AI_AGENT] TypeTool error:', error);
+      throw new Error(`Type failed: ${error.message}`);
     }
   }
 }
 
-// Tool for handling autocomplete/combobox interactions (Google Flights, etc.)
-class SelectAutocompleteTool extends BrowserTool {
+// Find elements using modern locator strategies (inspired by Playwright)
+class FindElementTool extends BrowserTool {
   constructor() {
     super(
-      "select_autocomplete",
-      "Fill an autocomplete/combobox field and select the first matching option. Designed for ARIA combobox patterns like Google Flights airport fields. This tool types the value, waits for the dropdown to appear, then uses keyboard navigation to select the first option.",
+      "find_element",
+      "Find elements using role-based, label-based, or text-based locators. Better than CSS selectors for dynamic content.",
       z.object({
-        tabId: CommonToolArgs.tabId,
-        selector: CommonToolArgs.selector.describe("CSS selector for the input or combobox element"),
-        value: CommonToolArgs.value.describe("Value to type into the field"),
-        waitTimeout: z.number().min(500).max(10000).default(3000).describe("Milliseconds to wait for dropdown options"),
-        retryAttempts: z.number().min(1).max(5).default(3).describe("Number of attempts if selection fails")
+        tabId: CommonToolArgs.tabId.optional().describe("Tab ID (optional - will use active tab if not specified)"),
+        locator: z.object({
+          role: z.string().optional().describe("ARIA role (e.g., 'button', 'textbox', 'combobox')"),
+          name: z.string().optional().describe("Accessible name or aria-label"),
+          text: z.string().optional().describe("Visible text content"),
+          placeholder: z.string().optional().describe("Placeholder text for inputs"),
+          title: z.string().optional().describe("Title attribute"),
+          selector: z.string().optional().describe("CSS selector as fallback")
+        }).describe("Locator options - at least one required"),
+        options: z.object({
+          exact: z.boolean().default(false).optional().describe("Require exact text match"),
+          timeout: z.number().min(0).max(30000).default(5000).optional().describe("Wait timeout in ms")
+        }).optional()
       })
     );
   }
 
-  async call({ tabId, selector, value, waitTimeout = 3000, retryAttempts = 3 }) {
+  async call({ tabId, locator, options = {} }) {
     try {
       const validTabId = await getValidTabId(tabId);
-      console.log(`üéØ SelectAutocompleteTool: Filling ${selector} with "${value}" and selecting from dropdown`);
       
       await ensureContentScript(validTabId);
       
-      // Use retry logic for robustness
-      const retryWithBackoff = async (fn, attempts, baseDelay = 250) => {
-        for (let i = 0; i < attempts; i++) {
-          try {
-            return await fn();
-          } catch (error) {
-            if (i === attempts - 1) throw error;
-            const delay = baseDelay * Math.pow(2, i);
-            console.log(`‚è≥ Attempt ${i + 1} failed, retrying in ${delay}ms:`, error.message);
-            await new Promise(resolve => setTimeout(resolve, delay));
-          }
-        }
+      const command = {
+        type: 'FIND_ELEMENT',
+        data: { locator, options }
       };
-
-      const result = await retryWithBackoff(async () => {
-        const response = await chrome.tabs.sendMessage(validTabId, {
-          type: "selectAutocomplete",
-          data: { selector, value, waitTimeout }
-        });
-        
-        if (response && response.error) {
-          throw new Error(`Content script error: ${response.error}`);
-        }
-        
-        return response;
-      }, retryAttempts);
-
-      console.log(`‚úÖ Successfully selected autocomplete option for ${selector}`);
-      return `Selected autocomplete option for ${selector} with value "${value}"`;
       
+      const response = await chrome.tabs.sendMessage(validTabId, command);
+      
+      if (response && response.error) {
+        throw new Error(`Find element failed: ${response.error}`);
+      }
+      
+      return `Found ${response.count} element(s) matching locator: ${JSON.stringify(response.elements)}`;
     } catch (error) {
-      console.error('‚ùå SelectAutocompleteTool error:', error);
-      const errorMsg = error.message.includes('Could not establish connection') 
-        ? 'Content script not available - page may need to be refreshed'
-        : error.message;
-      throw new Error(`Select autocomplete failed: ${errorMsg}`);
+      console.error('[AI_AGENT] FindElementTool error:', error);
+      throw new Error(`Find element failed: ${error.message}`);
     }
   }
 }
@@ -1766,30 +1784,43 @@ class FillFormFieldWithRetryTool extends BrowserTool {
 }
 
 export const browserTools = [
+  // Core agent control tools
   new FinishTool(),
   new ReasoningTool(),
+  
+  // Tab management
   new GetActiveTabTool(),
   new CreateNewTabTool(),
-  new GetPageContentTool(),
-  new GetDomStructureTool(),
   new NavigateToURLTool(),
-  new FillFormFieldTool(),
-  new SelectAutocompleteTool(),
+  
+  // Simplified command tools (industry best practices)
+  new ClickTool(),
+  new TypeTool(),
+  new FillTool(),
+  new GetPageTool(),
+  new FindElementTool(),
+  
+  // Legacy tools for backward compatibility
   new ClickElementTool(),
+  new FillFormFieldTool(),
+  new GetPageContentTool(),
+  new GetDomStructureTool(),
+  
+  // Utility tools
   new ScrollTool(),
+  new WaitForElementTool(),
+  new TakeScreenshotTool(),
   new UpdateSuggestionsTool(),
   new AskUserQuestionTool(),
-  new TakeScreenshotTool(),
-  new ClickAtCoordinatesTool(),
-  new TypeAtCoordinatesTool(),
-  new WaitForElementTool(),
-  // Enhanced browser-use inspired tools for more powerful agent interactions
-  new HighlightElementsTool(),
   new KeyboardShortcutTool(),
+  
+  // Advanced interaction tools
+  new HighlightElementsTool(),
   new HoverElementTool(),
   new SearchAndScrollToTextTool(),
   new DragDropTool(),
-  // Intelligent verification and retry tools for robust agent behavior
+  
+  // Verification and intelligence tools
   new VerifyActionTool(),
   new ReflectOnFailureTool(),
   new ClickElementWithRetryTool(),
diff --git a/chrome/browser/resources/vibe/background.js b/chrome/browser/resources/vibe/background.js
index 6a7de48ff5..865795d7e6 100644
--- a/chrome/browser/resources/vibe/background.js
+++ b/chrome/browser/resources/vibe/background.js
@@ -5,12 +5,13 @@ console.log('üöÄ [BACKGROUND] Vibe AI Agent background script starting...');
 // Import the real LangChain agent implementation
 import { VibeLangchainAgent } from "./ai_agent.js";
 
-// Global AI agent instance
-const aiAgent = new VibeLangchainAgent();
-
-// Track current operations for stopping
-const currentOperations = new Map();
+// Global variables
+let currentOperations = new Map();
+let aiAgent = null;
+let chatHistory = []; // Persistent chat history
 
+// Initialize AI agent instance
+aiAgent = new VibeLangchainAgent();
 
 // Simple natural language query detection
 function isNaturalLanguageQuery(url) {
@@ -147,15 +148,23 @@ chrome.webNavigation.onBeforeNavigate.addListener(async (details) => {
     console.log('üéØ [NAVIGATION] Natural language query detected, intercepting navigation');
     
     try {
-      // Cancel the navigation
-      await chrome.tabs.update(details.tabId, { url: 'about:blank' });
+      // Create a new tab for AI agent to work in
+      const newTab = await chrome.tabs.create({
+        url: 'https://www.google.com', // Start with a useful page
+        active: false // Don't switch to it immediately
+      });
+      
+      // Redirect the original tab to a simple page
+      await chrome.tabs.update(details.tabId, { url: 'chrome://newtab/' });
       
-      // Open side panel
+      // Open side panel on the original tab
       await openSidePanel(details.tabId);
       
       // Wait for side panel to fully load before sending messages
       await new Promise(resolve => setTimeout(resolve, 2000));
       
+      console.log(`üéØ [NAVIGATION] Created new working tab ${newTab.id} for AI agent, using original tab ${details.tabId} for side panel`);
+      
       // Add user query to conversation
       await sendStatusUpdate(details.tabId, {
         type: 'USER_QUERY',
@@ -178,15 +187,15 @@ chrome.webNavigation.onBeforeNavigate.addListener(async (details) => {
       // Get AI configuration for API key
       const config = await getAIConfiguration();
       
-      // Process the query with AI agent
+      // Process the query with AI agent using the new working tab
       console.log('ü§ñ [AI] Processing query with AI agent:', extractedQuery);
       const result = await aiAgent.processUserRequest({
         user_request: extractedQuery,
-        tabId: details.tabId,
+        tabId: newTab.id, // Use the new working tab for AI operations
         config: config
       });
       
-      console.log('‚úÖ [AI] Query processing completed:', result);
+      console.log('‚úÖ [AI] Query processing completed:', JSON.stringify(result, null, 2));
       
       // Adapt LangChain result format to expected format
       const adaptedResult = {
@@ -218,7 +227,7 @@ async function getAIConfiguration() {
     // Use settings bridge to get combined settings (browser + extension + environment)
     const combined = await getBrowserSettingsViaMessage();
     
-    console.log('üîë [CONFIG] Settings bridge loaded config:', combined);
+    console.log('üîë [CONFIG] Settings bridge loaded config:', JSON.stringify(combined, null, 2));
     
     // Get the active provider
     const provider = combined.provider || 'openai';
@@ -324,12 +333,12 @@ async function getBrowserSettingsViaMessage() {
         geminiApiKey: vibePrefs['vibe_ai.gemini_api_key'] || null
       };
       
-      console.log('üîß [CONFIG] Final environment configuration:', {
+      console.log('üîß [CONFIG] Final environment configuration:', JSON.stringify({
         openaiConfigured: environmentConfiguration.openaiConfigured,
         geminiConfigured: environmentConfiguration.geminiConfigured,
         hasOpenaiKey: !!environmentConfiguration.openaiApiKey,
         hasGeminiKey: !!environmentConfiguration.geminiApiKey
-      });
+      }, null, 2));
       
       return {
         provider: vibePrefs['vibe_ai.provider'] || 'auto',
@@ -548,6 +557,16 @@ chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
       handleAIAgentRequest(message, sendResponse);
       return true; // Keep the message channel open for async response
       
+    case 'CHAT4_MESSAGE':
+      // Handle Chat4 messages and start AI agent
+      handleChat4Message(message, sendResponse);
+      return true; // Keep the message channel open for async response
+      
+    case 'getChatHistory':
+      // Handle chat history requests
+      handleChatHistoryRequest(message, sendResponse);
+      return true; // Keep the message channel open for async response
+      
     default:
       console.log('‚ùì Unknown message type:', message.type);
       sendResponse({ success: false, error: 'Unknown message type' });
@@ -640,6 +659,13 @@ async function handleSidePanelCommand(message, sendResponse) {
       return;
     }
 
+    // Add user message to chat history
+    console.log(`üí¨ [BACKGROUND] Adding user message to chat history: "${command}"`);
+    addMessageToHistory('user', command, {
+      source: source,
+      operationId: operationId
+    });
+
     // Get AI configuration for API key
     const config = await getAIConfiguration();
     
@@ -761,7 +787,7 @@ async function handleAIAgentRequest(message, sendResponse) {
     }
     
     // Process the request with the AI agent
-    const response = await aiAgent.process({
+    const response = await aiAgent.processUserRequest({
       user_request,
       tabId,
       config
@@ -787,4 +813,90 @@ async function handleAIAgentRequest(message, sendResponse) {
   }
 }
 
+// Handle Chat4 messages and start AI agent
+async function handleChat4Message(message, sendResponse) {
+  console.log('üí¨ [CHAT4_MESSAGE] Processing message from Chat4:', message.content);
+  
+  try {
+    const { content, tabId } = message;
+    
+    if (!content) {
+      throw new Error('No message content provided');
+    }
+    
+    // Get the current tab if not provided
+    const currentTabId = tabId || (await chrome.tabs.query({ active: true, currentWindow: true }))[0]?.id;
+    
+    if (!currentTabId) {
+      throw new Error('No active tab found');
+    }
+    
+    console.log(`üöÄ [CHAT4_MESSAGE] Starting AI agent for tab ${currentTabId} with message: "${content}"`);
+    
+    // Process the request with the AI agent (same as navigation interception)
+    const response = await aiAgent.processUserRequest({
+      user_request: content,
+      tabId: currentTabId,
+      config: await getAIConfiguration()
+    });
+    
+    console.log('‚úÖ [CHAT4_MESSAGE] AI agent response:', response);
+    
+    // Send successful response back to Chat4
+    sendResponse({
+      success: true,
+      response: response.content || response.message || response
+    });
+    
+  } catch (error) {
+    console.error('‚ùå [CHAT4_MESSAGE] Error processing Chat4 message:', error);
+    
+    // Send error response back to Chat4
+    sendResponse({
+      success: false,
+      error: error.message || 'Failed to process Chat4 message'
+    });
+  }
+}
+
+// Chat History Management Functions
+function addMessageToHistory(type, content, metadata = {}) {
+  const message = {
+    id: Date.now() + Math.random(),
+    type: type, // 'user', 'agent', 'system'
+    content: content,
+    timestamp: Date.now(),
+    ...metadata
+  };
+  
+  chatHistory.push(message);
+  console.log(`üí¨ [BACKGROUND] Added ${type} message to history:`, content.substring(0, 100));
+  
+  // Keep only last 100 messages to prevent memory issues
+  if (chatHistory.length > 100) {
+    chatHistory = chatHistory.slice(-100);
+  }
+  
+  return message;
+}
+
+function getChatHistory() {
+  console.log(`üìö [BACKGROUND] Returning chat history with ${chatHistory.length} messages`);
+  return chatHistory;
+}
+
+function clearChatHistory() {
+  chatHistory = [];
+  console.log('üóëÔ∏è [BACKGROUND] Chat history cleared');
+}
+
+// Handle chat history requests
+function handleChatHistoryRequest(message, sendResponse) {
+  console.log('üìñ [BACKGROUND] Chat history requested');
+  sendResponse({
+    success: true,
+    chatHistory: getChatHistory()
+  });
+}
+
 console.log('‚úÖ [BACKGROUND] Background script initialization complete');
\ No newline at end of file
diff --git a/chrome/browser/resources/vibe/content.js b/chrome/browser/resources/vibe/content.js
index 1bc8cd61a6..87013be00f 100644
--- a/chrome/browser/resources/vibe/content.js
+++ b/chrome/browser/resources/vibe/content.js
@@ -163,7 +163,7 @@ chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
     try {
       const diff = pendingMutations;
       pendingMutations = []; // Clear buffer after sending
-      console.log(`üìÑ Sending ${diff.length} DOM mutations as diff`);
+      console.log(`üìÑ Sending DOM mutations as diff: ${JSON.stringify(diff)}`);
       sendResponse({ diff, timestamp: Date.now(), success: true });
     } catch (error) {
       console.error('‚ùå Error getting page content diff:', error);
@@ -777,7 +777,7 @@ function isRelevantCombobox(combobox, selector) {
  * Fill input field, handle dropdown suggestions, and return page diff
  * Supports both regular inputs and dynamic combobox widgets like Google Flights
  */
-function fillInput(selector, value) {
+async function fillInput(selector, value) {
   // Get the page state before the input
   const beforeState = getPageStateSnapshot();
   
@@ -801,37 +801,41 @@ function fillInput(selector, value) {
     }
   }
   
+  // Enhanced combobox selectors with more Google Flights patterns (moved to outer scope)
+  const comboboxSelectors = [
+    // Aria-label based (most common)
+    `div[role="combobox"][aria-label*="from"]`,
+    `div[role="combobox"][aria-label*="From"]`,
+    `div[role="combobox"][aria-label*="departure"]`,
+    `div[role="combobox"][aria-label*="origin"]`,
+    `div[role="combobox"][aria-label*="where from"]`,
+    `div[role="combobox"][aria-label*="Where from"]`,
+    // To destination variants
+    `div[role="combobox"][aria-label*="to"]`,
+    `div[role="combobox"][aria-label*="To"]`,
+    `div[role="combobox"][aria-label*="destination"]`,
+    `div[role="combobox"][aria-label*="where to"]`,
+    `div[role="combobox"][aria-label*="Where to"]`,
+    // Placeholder based fallbacks
+    `div[role="combobox"][placeholder*="from"]`,
+    `div[role="combobox"][placeholder*="to"]`,
+    `div[role="combobox"][placeholder*="departure"]`,
+    // Google Flights specific patterns
+    `div[data-flt-ve][role="combobox"]`,
+    `div[jsaction][role="combobox"]`,
+    `[aria-expanded="false"][role="combobox"]`,
+    // Material Design patterns
+    `.VfPpkd-TkwUic[role="combobox"]`,
+    `.mdc-text-field[role="combobox"]`,
+    // Generic combobox detection
+    `div[role="combobox"]`,
+    `input[role="combobox"]`
+  ];
+
   // Step 3: If not found, try to handle dynamic combobox widgets
   if (!element) {
     console.log(`üéØ Trying combobox detection and activation...`);
     
-    // Enhanced combobox selectors with more Google Flights patterns
-    const comboboxSelectors = [
-      // Aria-label based (most common)
-      `div[role="combobox"][aria-label*="from"]`,
-      `div[role="combobox"][aria-label*="From"]`,
-      `div[role="combobox"][aria-label*="departure"]`,
-      `div[role="combobox"][aria-label*="origin"]`,
-      `div[role="combobox"][aria-label*="where from"]`,
-      `div[role="combobox"][aria-label*="Where from"]`,
-      // To destination variants
-      `div[role="combobox"][aria-label*="to"]`,
-      `div[role="combobox"][aria-label*="To"]`,
-      `div[role="combobox"][aria-label*="destination"]`,
-      `div[role="combobox"][aria-label*="where to"]`,
-      `div[role="combobox"][aria-label*="Where to"]`,
-      // Placeholder based fallbacks
-      `div[role="combobox"][placeholder*="from"]`,
-      `div[role="combobox"][placeholder*="to"]`,
-      `div[role="combobox"][placeholder*="departure"]`,
-      // Google Flights specific patterns
-      `div[data-flt-ve][role="combobox"]`,
-      `div[jsaction][role="combobox"]`,
-      `[aria-expanded="false"][role="combobox"]`,
-      // Generic combobox detection
-      `div[role="combobox"]`
-    ];
-    
     for (const comboSelector of comboboxSelectors) {
       const comboboxes = querySelectorAllDeep(document, comboSelector);
       
@@ -842,40 +846,14 @@ function fillInput(selector, value) {
         console.log(`üìç Found relevant combobox widget: ${comboSelector}`);
         console.log(`   - Element:`, combobox.outerHTML.substring(0, 200) + '...');
         
-        // Click the combobox to activate it and spawn the input
-        combobox.click();
-        combobox.focus();
-        console.log(`üñ±Ô∏è Clicked combobox, waiting for input to appear...`);
-        
-        // Wait for the input to appear, trying all flexible selectors
-        let attempts = 0;
-        while (!element && attempts < 15) {
-          for (const flexSelector of flexibleSelectors) {
-            element = querySelectorDeep(document, flexSelector);
-            if (element) {
-              console.log(`‚úÖ Input appeared with selector: ${flexSelector}`);
-              break;
-            }
-          }
-          
-          if (!element) {
-            // Trigger a reflow to allow DOM updates
-            document.body.offsetHeight;
-            // Small delay using a blocking approach for sync compatibility
-            const start = Date.now();
-            while (Date.now() - start < 100) { /* busy wait */ }
-          }
-          attempts++;
-        }
+        // Enhanced Material Design combobox activation
+        element = await activateMaterialCombobox(combobox, flexibleSelectors, value);
         
         if (element) {
-          console.log(`‚úÖ Input appeared after clicking combobox (attempt ${attempts})`);
+          console.log(`‚úÖ Successfully activated Material Design combobox`);
           break;
-        } else {
-          console.log(`‚ö†Ô∏è No input appeared after clicking combobox (tried ${attempts} times)`);
         }
         
-        if (element) break; // Break out of combobox loop if found
       }
       if (element) break; // Break out of selector loop if found
     }
@@ -1688,6 +1666,192 @@ function getIntelligentChangeSummary() {
   return changes;
 }
 
+/**
+ * Advanced Material Design combobox activation
+ * Handles Google Flights and other Material Design components
+ */
+async function activateMaterialCombobox(combobox, flexibleSelectors, value) {
+  let element = null;
+  
+  // Strategy 1: Multiple interaction approaches
+  const activationStrategies = [
+    // Strategy A: Standard click + focus
+    () => {
+      combobox.click();
+      combobox.focus();
+    },
+    // Strategy B: Mouse events sequence
+    () => {
+      const rect = combobox.getBoundingClientRect();
+      const centerX = rect.left + rect.width / 2;
+      const centerY = rect.top + rect.height / 2;
+      
+      ['mousedown', 'mouseup', 'click'].forEach(eventType => {
+        combobox.dispatchEvent(new MouseEvent(eventType, {
+          bubbles: true,
+          cancelable: true,
+          clientX: centerX,
+          clientY: centerY
+        }));
+      });
+      combobox.focus();
+    },
+    // Strategy C: Keyboard activation
+    () => {
+      combobox.focus();
+      combobox.dispatchEvent(new KeyboardEvent('keydown', {
+        bubbles: true,
+        key: 'Enter',
+        code: 'Enter',
+        keyCode: 13
+      }));
+    },
+    // Strategy D: Touch events for mobile-first components
+    () => {
+      const rect = combobox.getBoundingClientRect();
+      const centerX = rect.left + rect.width / 2;
+      const centerY = rect.top + rect.height / 2;
+      
+      combobox.dispatchEvent(new TouchEvent('touchstart', {
+        bubbles: true,
+        touches: [{
+          clientX: centerX,
+          clientY: centerY,
+          target: combobox
+        }]
+      }));
+      combobox.dispatchEvent(new TouchEvent('touchend', {
+        bubbles: true,
+        changedTouches: [{
+          clientX: centerX,
+          clientY: centerY,
+          target: combobox
+        }]
+      }));
+      combobox.click();
+    }
+  ];
+  
+  for (let strategyIndex = 0; strategyIndex < activationStrategies.length; strategyIndex++) {
+    console.log(`üîÑ Trying activation strategy ${strategyIndex + 1}/${activationStrategies.length}`);
+    
+    try {
+      // Execute activation strategy
+      activationStrategies[strategyIndex]();
+      
+      // Smart waiting with multiple detection methods
+      element = await waitForInputWithMultipleStrategies(flexibleSelectors, combobox, value);
+      
+      if (element) {
+        console.log(`‚úÖ Strategy ${strategyIndex + 1} succeeded`);
+        return element;
+      }
+    } catch (error) {
+      console.log(`‚ö†Ô∏è Strategy ${strategyIndex + 1} failed:`, error.message);
+    }
+  }
+  
+  return null;
+}
+
+/**
+ * Wait for input with multiple detection strategies
+ */
+async function waitForInputWithMultipleStrategies(flexibleSelectors, combobox, value) {
+  const maxAttempts = 20;
+  const baseDelay = 50;
+  
+  for (let attempt = 0; attempt < maxAttempts; attempt++) {
+    // Strategy 1: Try flexible selectors
+    for (const flexSelector of flexibleSelectors) {
+      const element = querySelectorDeep(document, flexSelector);
+      if (element && isElementVisible(element)) {
+        console.log(`‚úÖ Input found with selector: ${flexSelector} (attempt ${attempt + 1})`);
+        return element;
+      }
+    }
+    
+    // Strategy 2: Look for inputs that appeared near the combobox
+    const nearbyInputs = findNearbyInputs(combobox);
+    for (const input of nearbyInputs) {
+      if (isElementVisible(input) && canReceiveInput(input)) {
+        console.log(`‚úÖ Found nearby input (attempt ${attempt + 1})`);
+        return input;
+      }
+    }
+    
+    // Strategy 3: Look for any newly appeared inputs on the page
+    const allInputs = document.querySelectorAll('input[type="text"], input:not([type]), textarea');
+    for (const input of allInputs) {
+      if (isElementVisible(input) && canReceiveInput(input) && isLikelySearchInput(input, value)) {
+        console.log(`‚úÖ Found likely search input (attempt ${attempt + 1})`);
+        return input;
+      }
+    }
+    
+    // Progressive delay with DOM reflow
+    document.body.offsetHeight; // Force reflow
+    await sleep(baseDelay * (attempt + 1));
+  }
+  
+  console.log(`‚ö†Ô∏è No input appeared after ${maxAttempts} attempts`);
+  return null;
+}
+
+/**
+ * Find inputs near a combobox element
+ */
+function findNearbyInputs(combobox) {
+  const rect = combobox.getBoundingClientRect();
+  const threshold = 200; // pixels
+  
+  const allInputs = document.querySelectorAll('input, textarea');
+  return Array.from(allInputs).filter(input => {
+    const inputRect = input.getBoundingClientRect();
+    const distance = Math.sqrt(
+      Math.pow(inputRect.left - rect.left, 2) + 
+      Math.pow(inputRect.top - rect.top, 2)
+    );
+    return distance <= threshold;
+  });
+}
+
+/**
+ * Check if an input can receive text input
+ */
+function canReceiveInput(input) {
+  const type = input.type?.toLowerCase();
+  const readOnly = input.readOnly;
+  const disabled = input.disabled;
+  
+  return !readOnly && !disabled && 
+    (!type || type === 'text' || type === 'search' || input.tagName.toLowerCase() === 'textarea');
+}
+
+/**
+ * Check if an input is likely a search input based on context
+ */
+function isLikelySearchInput(input, value) {
+  const placeholder = input.placeholder?.toLowerCase() || '';
+  const ariaLabel = input.getAttribute('aria-label')?.toLowerCase() || '';
+  const className = input.className?.toLowerCase() || '';
+  
+  // Check if it's related to location/flight search
+  const searchTerms = ['from', 'to', 'departure', 'destination', 'origin', 'where', 'airport', 'city'];
+  const relevantTerms = searchTerms.some(term => 
+    placeholder.includes(term) || ariaLabel.includes(term) || className.includes(term)
+  );
+  
+  return relevantTerms || input.offsetParent !== null; // visible input
+}
+
+/**
+ * Sleep utility for async waiting
+ */
+function sleep(ms) {
+  return new Promise(resolve => setTimeout(resolve, ms));
+}
+
 /**
  * Enhanced page content extraction using the content extractor
  */
-- 
2.50.0

